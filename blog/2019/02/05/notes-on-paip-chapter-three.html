<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/css/main.css"/><link rel="shortcut icon" href="/images/favicon.png"/><title>PAIP读书笔记（第三章）</title></head><body><header><span id="site-name"><a href="/">dram.me</a></span><nav><ul><li><a href="/blog/about.html">About</a></li><li><a href="/logo/">LOGO</a></li></ul></nav></header><article><h1>PAIP读书笔记（第三章）</h1><time>05 Feb 2019</time><p>以下是阅读PAIP<a href="https://github.com/norvig/paip-lisp/blob/master/docs/chapter3.md">第三章</a>部分的一些笔记：</p><ol><li><em>Special Forms</em>是指Common Lisp原生的语法结构，而<em>Macros</em>是指可以展开为special forms和functions组合的结构；</li><li><code>nconc</code>不需要申请额外的内存，只是将前链表和后链表相连接；</li><li><code>defstruct</code>获得的结构体，可以通过<code>#S(type ...)</code>字面常量表示，也就是说默认支持序列化和反序列化，这在数据交互层面很有用，不过hash-table不支持；</li><li><code>trace</code>、<code>step</code>、<code>cerror</code>、<code>check-type</code>、<code>assert</code>这些运行时的诊断和修复工具是真正体现Common Lisp强大的地方；</li><li><code>(values)</code>类似于C语言中的<code>void</code>；</li><li><code>(setf (symbol-function ...) ...)</code>可以覆盖函数定义，对应的有<code>symbol-value</code>，不过只针对<em>special variables</em>，普通的局部变量不能用这种方式，因为Common Lisp和很多编译语言一样，在运行态，普通变量的名称已经在编译时去除了。</li></ol></article><footer><p>Copyright © 2007–2019 Xin Wang</p></footer></body></html>
