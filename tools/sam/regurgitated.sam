# This file is part of the SPFE Open Toolkit. See the accompanying license.txt file
# for applicable licenses.
# (c) Copyright Analecta Communications Inc. 2015 All Rights Reserved.
# Need test for unicode characters and numbers in names.
tests:(!en) SAM Parser Tests
    description:
        This document is the output of the test document processed by test.xslt. That stylesheet attempt to validate the outcome of tests by generating a string version of the markup under the `markup:`(sam) heading and comparing it to the text of the expected result as shown under the `result:` heading in the test file. This is not a perfect test. Two issues are known:

        1. Test are done on whitespace normalized versions of the XML markup strings. As such, they do not validly test situations where whitespace should be retained, such as in codeblocks and at the beginning of lines.


        2. The SAM parser outputs attributes in alphabetical order. (From an XML point of view, the order of attributes does not matter.) Test should be written such that the attributes in the `result:` section are in alphabetical order. If not, the test will fail even though the XML is semantically identical.


        When running this test you should receive one SAM Parser Warning:

        ```(terminal)
            SAM parser warning: Unannotated phrase found: {should be reported} If you are trying to insert curly braces into the document, use \{should be reported}.

        This is a test to make sure unannotated phrases are being reported correctly.

    test: Includes
        description:
            Include content from another SAM file.

        case: Local only annotations
            description:
                A local-only annotation is one which applies only to the current phrase. It is not taken into consideration in annotation lookup, so the lookup search will proceed to the next phrase with the same text. Annotation lookup will occur for a phrase with a local-only annotation, and the local annotation will be added to the looked up annotations, if any.

            source:
                ```(sam)
                    Testing {XML}(language) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}(language) testing {XML}(index)(language) testing {XML}(language).

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="language">XML</annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

        case: Simple include
            description:
                An include statement.

            source:
                ```(sam)
                    <<<(includeme.sam)

            markup:
                <<<(includeme.sam)

            result:
                ```(xml)
                    <message>
                    <title>Hello World.</title>
                    <p>This is the "include" test -- file.</p>
                    <grid>
                    <row>
                    <cell>foo</cell>
                    <cell>bar</cell>
                    </row>
                    <row>
                    <cell>baz</cell>
                    <cell>bat</cell>
                    </row>
                    </grid>
                    <p>Annotation lookup test: <phrase><annotation type="test">test phrase</annotation></phrase>.</p>
                    </message>

        case: Nested includes
            description:
                Including a file that itself includes a file.

            source:
                ```(sam)
                    <<<(includeme1.sam)

            markup:
                <<<(includeme1.sam)

            result:
                ```(xml)
                    <message>
                    <p>This file includes another file.</p>
                    <p>Nested includes work! Yipee!</p>
                    </message>

    test: Blocks
        description:
            Blocks are the basic building block of a SAM file. This whole document is a test case for blocks.

        case: Language metadata
            description:
                A block with language metadata.

            source:
                ```(sam)
                    section:(!es)
                        Feliz Navidad

            markup:
                section:(!es)
                    Feliz Navidad

            result:
                ```(xml)
                    <section xml:lang="es">
                        <p>Feliz Navidad</p>
                    </section>

        case: Citations
            description:
                A citation on the block.

            source:
                ```(sam)
                    section:(!es)[Mother McCree] Greeting
                        Feliz Navidad

            markup:
                section:(!es)[Mother McCree] Greeting
                    Feliz Navidad

            result:
                ```(xml)
                    <section xml:lang="es">
                        <citation value="Mother McCree"/>
                        <title>Greeting</title>
                        <p>Feliz Navidad</p>
                    </section>

        case: Escaping block syntax
            description:
                Escape colon to prevent single word followed by colon being recognized as a block.

            source:
                ```(sam)
                    and\:

            markup:
                and\:

            result:
                ```(xml)
                    <p>and:</p>

        case: Complex block structure
            description:
                A complex block with various structures inside.

            source:
                ```(sam)
                    document:
                        head:(#foo)
                            foo: barney {and}(conjunction) betty
                            baz: bat
                            $name=fred {and}(conjunction) wilma
                            history:: date, author, comment, status
                                2014-06-23, mbaker, New\, Topic, In progress
                                2016-07-01, mbaker, Revision, In progress
                            index:: type, term
                                feature, fragment
                                feature, fragments
                        body: How Fragments Work
                            Stuff on how fragments work.

            markup:
                document:
                    head:(#foo)
                        foo: barney {and}(conjunction) betty
                        baz: bat
                        $name=fred {and}(conjunction) wilma
                        history::date, author, comment, status
                            2014-06-23, mbaker, New\, Topic, In progress
                            2016-07-01, mbaker, Revision, In progress
                        index::type, term
                            feature, fragment
                            feature, fragments
                    body: How Fragments Work
                        Stuff on how fragments work.

            result:
                ```(xml)
                    <document>
                    <head name="foo">
                    <foo>barney <phrase><annotation type="conjunction">and</annotation></phrase> betty</foo>
                    <baz>bat</baz>
                    <variable name="name">fred <phrase><annotation type="conjunction">and</annotation></phrase> wilma</variable>
                    <history>
                    <record>
                    <date>2014-06-23</date>
                    <author>mbaker</author>
                    <comment>New, Topic</comment>
                    <status>In progress</status>
                    </record>
                    <record>
                    <date>2016-07-01</date>
                    <author>mbaker</author>
                    <comment>Revision</comment>
                    <status>In progress</status>
                    </record>
                    </history>
                    <index>
                    <record>
                    <type>feature</type>
                    <term>fragment</term>
                    </record>
                    <record>
                    <type>feature</type>
                    <term>fragments</term>
                    </record>
                    </index>
                    </head>
                    <body>
                    <title>How Fragments Work</title>
                    <p>Stuff on how fragments work.</p>
                    </body>
                    </document>

        case: Paragraph with colon in first word
            description:
                Case related to issue #94.

            source:
                ```(sam)
                    article: Foo
                    
                        foo{bar}(http://www.example.com/).
                    
                        `foo::bar` baz.

            markup:
                article: Foo
                    foo{bar}(link "http://www.example.com/").

                    `foo::bar` baz.

            result:
                ```(xml)
                    <article>
                    <title>Foo</title>
                    <p>foo<phrase><annotation type="link" specifically="http://www.example.com/">bar</annotation></phrase>.</p>
                    <p><code>foo::bar</code> baz.</p>
                    </article>

    # FIXME: Need tests for comments.
    test: Remarks
        description:
            Remarks are a type of comment that is attributed to an author and is used for commenting editorially on the document.

        case: Simple remark
            description:
                Just a simple remark. Nothing fancy.

            source:
                ```(sam)
                    !!!(mbaker)
                        This is a remark.

            markup:
                !!!(mbaker)
                    This is a remark.


            result:
                ```(xml)
                    <remark attribution="mbaker">
                    <p>This is a remark.</p>
                    </remark>

        case: Complex remark
            description:
                A little bit more complex.

            source:
                ```(sam)
                    !!!(Charles André Joseph Marie de Gaulle !@#$%^&*(((({}":<>)(*cdg1)(!fr)
                        This is a remark.

            markup:
                !!!(Charles André Joseph Marie de Gaulle !@#$%^&*(((({}":<>)(*cdg1)(!fr)
                    This is a remark.


            result:
                ```(xml)
                    <remark attribution="Charles André Joseph Marie de Gaulle !@#$%^&amp;*(((({}&quot;:&lt;&gt;" id="cdg1" xml:lang="fr">
                    <p>This is a remark.</p>
                    </remark>

    test: Fields
        description:
            A field is a block without children. A field value does not get wrapped in a title element. It is simple the value of the field.

        case: Nested fields
            description:
                Nested fields. Anything with a child, of course, is a block, not a field.

            source:
                ```(sam)
                    address:
                        name: Fred Flintstone
                        address: Bedrock
                        era: Stone Age

            markup:
                address:
                    name: Fred Flintstone
                    address: Bedrock
                    era: Stone Age
            result:
                ```(xml)
                    <address>
                    <name>Fred Flintstone</name>
                    <address>Bedrock</address>
                    <era>Stone Age</era>
                    </address>

    test: Paragraphs
        description:
            A paragraph is a block of text over consecutive lines.

        case: Paragraph
            description:
                A simple multi-line paragraph ending with a blank space.

            source:
                ```(sam)
                    Wafting zephyrs
                    quickly vexed
                    Jumbo.

            markup:
                Wafting zephyrs quickly vexed Jumbo.

            result:
                ```(xml)
                    <p>Wafting zephyrs quickly vexed Jumbo.</p>

        case: With annotated phrase
            description:
                A paragraph over multiple lines with an annotated phrase.

            source:
                ```(sam)
                    This is a {paragraph}(foo)
                    that wraps across
                    multiple lines.

            markup:
                This is a {paragraph}(foo) that wraps across multiple lines.

            result:
                ```(xml)
                    <p>This is a <phrase><annotation type="foo">paragraph</annotation></phrase> that wraps across multiple lines.</p>

    test: Ordered lists
        description:
            Ordered lists are created by starting a line with a number followed by a period. Exact numbers are not retained.

        case: Ordered list with spaces
            description:
                Ordered lists can have blank lines between the items.

            source:
                ```(sam)
                    0. One
                    
                    0. Two
                    
                    99999. Three

            markup:
                1. One


                2. Two


                3. Three


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>

        case: Ordered list no spaces
            description:
                List are also recognized without space between items. List items can wrap to another line if more indented than the number. Additional paragraphs can be included if more indented than the number.

            source:
                ```(sam)
                    0. One
                    0. Two this
                       paragraph wraps.
                    
                       This is another para in the list item.
                    99999. Three

            markup:
                1. One


                2. Two this paragraph wraps.

                   This is another para in the list item.


                3. Three


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two this paragraph wraps.</p>
                    <p>This is another para in the list item.</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>

        case: Ordered list mixed spacing
            description:
                Ordered list with inconsistent spacing.

            source:
                ```(sam)
                    0. One
                    
                    0. Two
                    99999. Three
                    
                    7. Four

            markup:
                1. One


                2. Two


                3. Three


                4. Four


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested ordered list with spaces
            description:
                Ordered lists at different indents, with spaces between lines.

            source:
                ```(sam)
                    0. One
                    
                    0. Two x
                    
                        5. Two and a quarter x
                    
                        6. Two and a half
                    
                        9. Two and three quarters
                    
                    99999. Three
                    
                    7. Four

            markup:
                1. One


                2. Two x

                    1. Two and a quarter x


                    2. Two and a half


                    3. Two and three quarters



                3. Three


                4. Four


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two x</p>
                    <ol>
                    <li>
                    <p>Two and a quarter x</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ol>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested ordered lists with no spaces
            description:
                Ordered lists at different indents, with no spaces between lines.

            source:
                ```(sam)
                    0. One
                    0. Two z
                        5. Two and a quarter z
                        6. Two and a half
                        9. Two and three quarters
                    99999. Three
                    7. Four

            markup:
                1. One


                2. Two z

                    1. Two and a quarter z


                    2. Two and a half


                    3. Two and three quarters



                3. Three


                4. Four


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two z</p>
                    <ol>
                    <li>
                    <p>Two and a quarter z</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ol>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested ordered list with mixed spacing
            description:
                Ordered lists at different indents, with some spaces between lines.

            source:
                ```(sam)
                    0. One
                    0. Two r
                        5. Two and a quarter r
                    
                        6. Two and a half
                        9. Two and three quarters
                    
                    99999. Three
                    
                    7. Four

            markup:
                1. One


                2. Two r

                    1. Two and a quarter r


                    2. Two and a half


                    3. Two and three quarters



                3. Three


                4. Four


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two r</p>
                    <ol>
                    <li>
                    <p>Two and a quarter r</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ol>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

    test: Unordered lists
        description:
            Unordered lists are indicated by starting a line with `*`.

        case: Unordered list with spaces
            description:
                A list with spaces between the lines.

            source:
                ```(sam)
                    * One
                    
                    * Two t
                    
                    * Three

            markup:
                * One

                * Two t

                * Three

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two t</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>

        case: Unordered list no spaces
            description:
                A list with no spaces between the lines.

            source:
                ```(sam)
                    * One
                    * Two y
                    * Three

            markup:
                * One

                * Two y

                * Three

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two y</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>

        case: Unordered list mixed spacing
            description:
                A list with mixed spacing between the lines.

            source:
                ```(sam)
                    * One
                    * Two u
                    
                    * Three
                    * Four

            markup:
                * One

                * Two u

                * Three

                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two u</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>

        case: Nested list with spaces
            description:
                Nested lists separated by spaces.

            source:
                ```(sam)
                    * One
                    
                    * Two i
                    
                        * Two and a quarter
                    
                        * Two and a half
                    
                        * Two and three quarters
                    
                    * Three
                    
                    * Four

            markup:
                * One

                * Two i

                    * Two and a quarter

                    * Two and a half

                    * Two and three quarters

                * Three

                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two i</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>

        case: Nested unordered list with no spaces
            description:
                Nested lists not separated by spaces.

            source:
                ```(sam)
                    * One
                    * Two k
                        * Two and a quarter
                        * Two and a half
                        * Two and three quarters
                    * Three
                    * Four

            markup:
                * One

                * Two k

                    * Two and a quarter

                    * Two and a half

                    * Two and three quarters

                * Three

                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two k</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>

        case: Nested unordered list with mixed spacing
            description:
                Nested lists separated by some spaces.

            source:
                ```(sam)
                    * One
                    * Two p
                        * Two and a quarter p
                    
                        * Two and a half
                        * Two and three quarters
                    
                    * Three
                    * Four

            markup:
                * One

                * Two p

                    * Two and a quarter p

                    * Two and a half

                    * Two and three quarters

                * Three

                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two p</p>
                    <ul>
                    <li>
                    <p>Two and a quarter p</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>

    test: Mixed lists
        description:
            You can nest ordered and unordered lists inside each other or follow a list of one type with a list of another type.

        case: Nested mixed lists with spaces
            description:
                Unordered inside ordered list, spaces between lines.

            source:
                ```(sam)
                    0. One
                    
                    0. Two a
                    
                        * Two and a quarter
                    
                        * Two and a half
                    
                        * Two and three quarters
                    
                    99999. Three
                    
                    7. Four

            markup:
                1. One


                2. Two a

                    * Two and a quarter

                    * Two and a half

                    * Two and three quarters


                3. Three


                4. Four


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two a</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested mixed lists with no spaces
            description:
                Unordered inside ordered list, no spaces between lines.

            source:
                ```(sam)
                    0. One
                    0. Two s
                        * Two and a quarter
                        * Two and a half
                        * Two and three quarters
                    99999. Three
                    7. Four

            markup:
                1. One


                2. Two s

                    * Two and a quarter

                    * Two and a half

                    * Two and three quarters


                3. Three


                4. Four


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two s</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested numbered lists with mixed spacing
            description:
                Unordered inside ordered list, some spaces between lines.

            source:
                ```(sam)
                    0. One
                    
                    0. Two d
                        * Two and a quarter
                    
                        * Two and a half
                        * Two and three quarters
                    99999. Three times
                           three is nine.
                    
                           Four times four is sixteen.
                    
                           Five time five is twenty five.
                    
                    
                    7. Four

            markup:
                1. One


                2. Two d

                    * Two and a quarter

                    * Two and a half

                    * Two and three quarters


                3. Three times three is nine.

                   Four times four is sixteen.

                   Five time five is twenty five.


                4. Four


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two d</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three times three is nine.</p>
                    <p>Four times four is sixteen.</p>
                    <p>Five time five is twenty five.</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Space between lists
            description:
                An ordered list can follow an unordered list directly and vice versa.

            source:
                ```(sam)
                    * One
                    * Two f
                    * Three
                    
                    1. One
                    2. Two g
                    3. Three

            markup:
                * One

                * Two f

                * Three

                1. One


                2. Two g


                3. Three


            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two f</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two g</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>

        case: No space between lists
            description:
                An unordered list followed by an ordered list with no space between them.

            source:
                ```(sam)
                    * One
                    * Two h
                    * Three
                    1. One
                    2. Two j
                    3. Three

            markup:
                * One

                * Two h

                * Three

                1. One


                2. Two j


                3. Three


            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two h</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two j</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>

    test: Literal lists
        description:
            Ordered lists have the number stripped away and are renumbered on output. Unordered list have their `*` stripped away and replaced with the style of bullet specified on output processing. If you want to preserve actual numbers and bullets in your lists, you need to escape them so that the lines are not recognized as lists items.

        case: Literal numbered list using `\` to escape `.`
            description:
                To have a list number recognized as a literal, escape the period following the number (not the number itself). Because these are now paragraphs, not lists, you must put spaces between items or they will be run together into one paragraph.

            source:
                ```(sam)
                    2\. This is just a paragraph
                    
                    4\. This is just a paragraph
                    
                    9\. This is just a paragraph

            markup:
                2\. This is just a paragraph

                4\. This is just a paragraph

                9\. This is just a paragraph

            result:
                ```(xml)
                    <p>2. This is just a paragraph</p>
                    <p>4. This is just a paragraph</p>
                    <p>9. This is just a paragraph</p>

        case: Literal unordered list using `\` to escape `*`
            description:
                To have a list number recognized as a literal, escape the `*`. Because these are now paragraphs, not lists, you must put spaces between items or they will be run together into one paragraph.

            source:
                ```(sam)
                    \* This is just a paragraph
                    
                    \* This is just a paragraph
                    
                    \* This is just a paragraph

            markup:
                \* This is just a paragraph

                \* This is just a paragraph

                \* This is just a paragraph

            result:
                ```(xml)
                    <p>* This is just a paragraph</p>
                    <p>* This is just a paragraph</p>
                    <p>* This is just a paragraph</p>

    test: Labeled lists
        description:
            You can create lists with labels rather than bullets. The label is contained between two pipe characters. There must be no space between the opening pipe and the first character of the label (otherwise it will be parsed as a line).

        case: Simple labeled list
            description:
                A labeled list.

            source:
                ```(sam)
                    |Do| a deer,
                         a female deer
                    |Re| a drop of
                         golden sun
                    
                         Is it a particle or a wave?
                    |Me| a name I call myself
                    |Fa| a long long way to run
                    |So| a needle pulling thread
                    |La| a note to follow so
                    |Te| a drink with jam and bread

            markup:
                |Do| a deer, a female deer

                |Re| a drop of golden sun

                   Is it a particle or a wave?

                |Me| a name I call myself

                |Fa| a long long way to run

                |So| a needle pulling thread

                |La| a note to follow so

                |Te| a drink with jam and bread

            result:
                ```(xml)
                    <ll>
                    <li>
                    <label>Do</label>
                    <p>a deer, a female deer</p>
                    </li>
                    <li>
                    <label>Re</label>
                    <p>a drop of golden sun</p>
                    <p>Is it a particle or a wave?</p>
                    </li>
                    <li>
                    <label>Me</label>
                    <p>a name I call myself</p>
                    </li>
                    <li>
                    <label>Fa</label>
                    <p>a long long way to run</p>
                    </li>
                    <li>
                    <label>So</label>
                    <p>a needle pulling thread</p>
                    </li>
                    <li>
                    <label>La</label>
                    <p>a note to follow so</p>
                    </li>
                    <li>
                    <label>Te</label>
                    <p>a drink with jam and bread</p>
                    </li>
                    </ll>

        case: XML markup characters in list labels
            description:
                Making sure that the contents of a list label are properly escaped when generating XML.

            source:
                ```(sam)
                  |foo1 & bar1| foobar1
                  |foo2 & bar2| foobar2
                  |foo3 & bar3| foobar3

            markup:
                |foo1 \& bar1| foobar1

                |foo2 \& bar2| foobar2

                |foo3 \& bar3| foobar3

            result:
                ```(xml)
                    <ll>
                    <li>
                    <label>foo1 &amp; bar1</label>
                    <p>foobar1</p>
                    </li>
                    <li>
                    <label>foo2 &amp; bar2</label>
                    <p>foobar2</p>
                    </li>
                    <li>
                    <label>foo3 &amp; bar3</label>
                    <p>foobar3</p>
                    </li>
                    </ll>

    test: Record sets
        description:
            Record sets are a structure similar to a database table. They record data in rows with identical column names. Column names are specified in the records set header.

        case: Recordset
            description:
                Test that recordsets are recognized correctly. Includes a test that character escapes are recognized in records and commas can be escaped.

            source:
                ```(sam)
                    history:: date, author, comment, status
                        2014-06-23, mbaker, New\, Topic, In progress
                        2016-07-01, mbaker, Revision, In progress

            markup:
                history::date, author, comment, status
                    2014-06-23, mbaker, New\, Topic, In progress
                    2016-07-01, mbaker, Revision, In progress
            result:
                ```(xml)
                    <history>
                    <record>
                    <date>2014-06-23</date>
                    <author>mbaker</author>
                    <comment>New, Topic</comment>
                    <status>In progress</status>
                    </record>
                    <record>
                    <date>2016-07-01</date>
                    <author>mbaker</author>
                    <comment>Revision</comment>
                    <status>In progress</status>
                    </record>
                    </history>

        case: Recordset with only one field name
            description:
                Test that a recordset works correctly with only one field.

            source:
                ```(sam)
                    filmography:: film
                        Rio Bravo
                        The Shootish

            markup:
                filmography::film
                    Rio Bravo
                    The Shootish
            result:
                ```(xml)
                    <filmography>
                    <record>
                    <film>Rio Bravo</film>
                    </record>
                    <record>
                    <film>The Shootish</film>
                    </record>
                    </filmography>

    test: Grids
        description:
            Grids are a simple form of table. They are purely a layout device with no semantic value. They have no table heads or row or column spanning. More complex tables can be modeled using explicit blocks. Labeled lists can be modeled using the labeled list structure. Database-like tables can be modeled using record sets.

        case: Grid with heads
            description:
                Table heads are simulated using bold in the top row of the grid.

            source:
                ```(sam)
                    +++
                        *Type*  | *Term*    | *Notes*
                        feature | fragment  | bing
                        feature | fragments | bang

            markup:
                +++
                    {Type}(bold) | {Term}(bold) | {Notes}(bold)
                    feature | fragment | bing
                    feature | fragments | bang

            result:
                ```(xml)
                    <grid>
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Term</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Notes</annotation></phrase></cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragments</cell>
                    <cell>bang</cell>
                    </row>
                    </grid>

        case: Grid with management domain attributes
            description:
                The same grid only with management domain attributes attached to the grid header.

                Note that SAM Parser sorts block attributes alphabetically for output, which makes it possible to test them with a simple string comparison (such as that performed by test.xslt). However, this is behavior of this parser, not a SAM language requirement.

            source:
                ```(sam)
                    +++(*foom)(#bar)(?baz)
                        *Type*  | *Term*    | *Notes*
                    
                        feature | fragment  | bing
                    
                        feature | fragments | bang

            markup:
                +++(?baz)(*foom)(#bar)
                    {Type}(bold) | {Term}(bold) | {Notes}(bold)
                    feature | fragment | bing
                    feature | fragments | bang

            result:
                ```(xml)
                    <grid conditions="baz" id="foom" name="bar">
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Term</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Notes</annotation></phrase></cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragments</cell>
                    <cell>bang</cell>
                    </row>
                    </grid>

        case: Grid with bold row
            description:
                Make an lower row bold.

            source:
                ```(sam)
                    +++
                        *Type*    | *Term*      | *Notes*
                        feature   | fragment    | bing
                        *feature* | *fragments* | *bang*

            markup:
                +++
                    {Type}(bold) | {Term}(bold) | {Notes}(bold)
                    feature | fragment | bing
                    {feature}(bold) | {fragments}(bold) | {bang}(bold)

            result:
                ```(xml)
                    <grid>
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Term</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Notes</annotation></phrase></cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell><phrase><annotation type="bold">feature</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">fragments</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">bang</annotation></phrase></cell>
                    </row>
                    </grid>

        case: Grid with side heads
            description:
                Grid with row headings rather than column headings.

            source:
                ```(sam)
                    +++
                        *Type*    | Term      | Notes
                        *feature* | fragment  | bing
                        *feature* | fragments | bang

            markup:
                +++
                    {Type}(bold) | Term | Notes
                    {feature}(bold) | fragment | bing
                    {feature}(bold) | fragments | bang

            result:
                ```(xml)
                    <grid>
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell>Term</cell>
                    <cell>Notes</cell>
                    </row>
                    <row>
                    <cell><phrase><annotation type="bold">feature</annotation></phrase></cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell><phrase><annotation type="bold">feature</annotation></phrase></cell>
                    <cell>fragments</cell>
                    <cell>bang</cell>
                    </row>
                    </grid>

    test: Blockquotes
        description:
            Blockquotes are introduced by three quotations marke (single or double). The content of a blockquote is normal SAM markup.

        case: Blockquote
            description:
                A blockquote with management domain metadata.

            source:
                ```(sam)
                    After this paragraph, there is a blockquote:
                    
                    """(*foo)(#bar)(?baz)
                        The quick brown fox jumps over the lazy dog.
                    
                        And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.

            markup:
                After this paragraph, there is a blockquote:

                """(?baz)(*foo)(#bar)
                    The quick brown fox jumps over the lazy dog.

                    And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.


            result:
                ```(xml)
                    <p>After this paragraph, there is a blockquote:</p>
                    <blockquote conditions="baz" id="foo" name="bar">
                    <p>The quick brown fox jumps over the lazy dog.</p>
                    <p>And the <phrase><annotation type="beast" specifically="bovine"><citation value="Mother Goose">cow</citation></annotation></phrase> jumps over the moon.</p>
                    </blockquote>

        case: Alternate block quote
            description:
                Blockquote with single quotes. Includes multiple citations.

            source:
                ```(sam)
                    This is another paragraph. Then there is an alternate blockquote:
                    
                    '''( #foo5)[Mother Goose](?bar)(?baz)[Father Time][*foo page 2][%key.bar12 page 22]
                        The quick brown fox jumps over the lazy dog.
                    
                    '''
                        This is a blockquote without a citation.

            markup:
                This is another paragraph. Then there is an alternate blockquote:

                """(?bar)(?baz)(#foo5)[Mother Goose][Father Time][*foo page 2][%key.bar12 page 22]
                    The quick brown fox jumps over the lazy dog.


                """
                    This is a blockquote without a citation.


            result:
                ```(xml)
                    <p>This is another paragraph. Then there is an alternate blockquote:</p>
                    <blockquote conditions="bar,baz" name="foo5">
                    <citation value="Mother Goose"/>
                    <citation value="Father Time"/>
                    <citation extra="page 2" idref="foo"/>
                    <citation extra="page 22" keyref="key.bar12"/>
                    <p>The quick brown fox jumps over the lazy dog.</p>
                    </blockquote>
                    <blockquote>
                    <p>This is a blockquote without a citation.</p>
                    </blockquote>

    test: Codeblocks
        description:
            A codeblock is a block of program code. A codeblock is treated as plain text and is not parsed as SAM markup. It will be copied to output exactly as it occurs in the source. Codeblocks are denoted by three back ticks at the start of a line. Codeblocks have a special annotation. The first word of an annotation on a codeblock is the language of the code.

        case: Simple codeblock
            description:
                A simple codeblock.

            source:
                ```(sam)
                    ```(pyt&#x68;on)(?foo)(!en)
                        def escape_for_xml(s):
                            t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                            try:
                                return s.translate(t)
                            except AttributeError:
                                return s

            markup:
                ```(python)(?foo)(!en)
                    def escape_for_xml(s):
                        t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s

            result:
                ```(xml)
                    <codeblock conditions="foo" language="python" xml:lang="en">
                    def escape_for_xml(s):
                        t = dict(zip([ord('&lt;'), ord('&gt;'), ord('&amp;')], ['&amp;lt;', '&amp;gt;', '&amp;amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s
                    </codeblock>

        case: Blank lines in codeblock
            description:
                Blank lines in a code block. The display of the result will be confusing here because the result is whitespace normalized for ease of comparison with the generated XML.

            source:
                ```(sam)
                    ```(sam)
                        warnings:
                            warning:(#warn_danger_domestic)
                                title: Danger
                    
                                Be very very careful. This could kill you.
                    
                            warning:(#warn_danger_foreign)
                                title: Look out!
                    
                                Pay close attention. You could really hurt yourself.

            markup:
                ```(sam)
                    warnings:
                        warning:(#warn_danger_domestic)
                            title: Danger
                    
                            Be very very careful. This could kill you.
                    
                        warning:(#warn_danger_foreign)
                            title: Look out!
                    
                            Pay close attention. You could really hurt yourself.

            result:
                ```(xml)
                    <codeblock language="sam">
                    warnings:
                        warning:(#warn_danger_domestic)
                            title: Danger
                    
                            Be very very careful. This could kill you.
                    
                        warning:(#warn_danger_foreign)
                            title: Look out!
                    
                            Pay close attention. You could really hurt yourself.
                    </codeblock>

        case: Codeblock with citation
            description:
                A codeblock with a citation.

            source:
                ```(sam)
                    ```(python)(?foo)[demos/foo.py]
                        def escape_for_xml(s):
                            t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                            try:
                                return s.translate(t)
                            except AttributeError:
                                return s

            markup:
                ```(python)(?foo)[demos/foo.py]
                    def escape_for_xml(s):
                        t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s

            result:
                ```(xml)
                    <codeblock conditions="foo" language="python">
                    <citation value="demos/foo.py"/>
                    def escape_for_xml(s):
                        t = dict(zip([ord('&lt;'), ord('&gt;'), ord('&amp;')], ['&amp;lt;', '&amp;gt;', '&amp;amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s
                    </codeblock>

        case: Invalid blockstart in codeblock
            description:
                This is an construct that raise an error in an actual document. Curious because lots of valid block starts in other codeblocks did not cause a problem. But this one raised an invalid block name error. Turns out this was caused by tabs instead of spaces used to indent the line, which promoted it to a higher level of the document hierarchy and thus outside the codeblock. But the test is worth keeping to make sure that the contents of codeblocks are not being interpreted as SAM markup.

            source:
                ```(sam)
                    ```
                        first-ordered-list-item =
                            {fontx: 12pt "Century Schoolbook"}<count=1>.[tab]
                        ordered-list-item =
                            {fonty: 12pt "Century Schoolbook"}<++count>.[tab]

            markup:
                ```
                    first-ordered-list-item =
                        {fontx: 12pt "Century Schoolbook"}<count=1>.[tab]
                    ordered-list-item =
                        {fonty: 12pt "Century Schoolbook"}<++count>.[tab]

            result:
                ```(xml)
                    <codeblock>
                    first-ordered-list-item =
                        {fontx: 12pt "Century Schoolbook"}&lt;count=1&gt;.[tab]
                    ordered-list-item =
                        {fonty: 12pt "Century Schoolbook"}&lt;++count&gt;.[tab]
                    </codeblock>

    test: Embedblock
        description:
            An embed is a block of markup or code in another language that is intended to be interpreted rather than displayed. For instance, it can be used to include an equation using LaTeX or a diagram using SVG.

        case: Simple embed
            description:
                Simple embed of an equation using LaTeX.

            source:
                ```(sam)
                    ```(=latexmathml)(*id13)(#name)(?a)(?b)
                        n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            markup:
                ```(=latexmathml)(?a)(?b)(*id13)(#name)
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            result:
                ```(xml)
                    <embedblock conditions="a,b" encoding="latexmathml" id="id13" name="name"> n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k </embedblock>

        case: Embedded XML
            description:
                A chunk of XML.

            source:
                ```(sam)
                    ```(=xml)
                        <?xml version="1.0" encoding="UTF-8"?>
                        <foo bar="bat">
                            <boo/>
                            <hoo/>
                        </foo>

            markup:
                ```(=xml)
                    <?xml version="1.0" encoding="UTF-8"?>
                    <foo bar="bat">
                        <boo/>
                        <hoo/>
                    </foo>

            result:
                ```(xml)
                    <embedblock encoding="xml">
                        &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
                        &lt;foo bar="bat"&gt; 
                        &lt;boo/&gt; 
                        &lt;hoo/&gt; 
                        &lt;/foo&gt;
                    </embedblock>

    test: Lines
        description:
            Lines allows you to create text with specific line breaks. Lines are created by beginning each line on a new line and starting with a `|` character. There must be one space after the `|`, which is discarded. All other spaces after `|` are retained. (Retained spaces are not tested for in text.xslt because the test normalize space.)

        case: Lines
            description:
                Lines with various annotations:

            source:
                ```(sam)
                    |(#foo2) You gotta walk that lonesome valley,[*bing page 22]
                    | You gotta walk it by yourself,
                    |(?bar) Nobody here can walk it for you,
                    |    You gotta walk it by yourself.

            markup:
                |(#foo2) You gotta walk that lonesome valley,[*bing page 22]
                | You gotta walk it by yourself,
                |(?bar) Nobody here can walk it for you,
                |    You gotta walk it by yourself.
            result:
                ```(xml)
                    <line name="foo2">You gotta walk that lonesome valley,<citation extra="page 22" idref="bing"/></line>
                    <line>You gotta walk it by yourself,</line>
                    <line conditions="bar">Nobody here can walk it for you,</line>
                    <line>   You gotta walk it by yourself.</line>

        case: Lines inside a blockquote
            description:
                Lines should work inside a block quote.

            source:
                ```(sam)
                    """[*bing page 22]
                        |(#foo2) You gotta walk that lonesome valley,[%bing page 22]
                        | You gotta walk it by yourself,
                        |(?bar) Nobody here can walk it for you,
                        |    You gotta walk it by yourself.

            markup:
                """[*bing page 22]
                    |(#foo2) You gotta walk that lonesome valley,[%bing page 22]
                    | You gotta walk it by yourself,
                    |(?bar) Nobody here can walk it for you,
                    |    You gotta walk it by yourself.

            result:
                ```(xml)
                    <blockquote>
                    <citation extra="page 22" idref="bing"/>
                    <line name="foo2">You gotta walk that lonesome valley,<citation extra="page 22" keyref="bing"/></line>
                    <line>You gotta walk it by yourself,</line>
                    <line conditions="bar">Nobody here can walk it for you,</line>
                    <line>   You gotta walk it by yourself.</line>
                    </blockquote>

    test: Attributes
        description:
            SAM supports four explicit attributes: ids, names, conditions, and language. There is no general attribute mechanism such as that in XML. You can generally encode the same data in SAM using fields or annotations.

            Attributes can be applied to blocks, phrases, and inserts. You cannot apply attributes to a paragraph, but you can wrap a paragraph in a fragment and apply attributes to the fragment.

            Attributes are applied using annotation markup, but with a specific initial character to denote each kind of attribute:

            * `(*id)` creates an ID attribute.

            * `(#name)` creates a name attribute.

            * `(?condition)` creates a condition attribute.

            * `(!en-CA)` creates a language attribute.

            You can only apply one id, name, or language attribute to a block or phrase. You can apply more than one condition attribute. On output to XML, the condition attributes will be converted to a single `conditions` attribute with the individual conditions separated by commas. (For which reason, condition statements can’t include commas.)

        case: Attributes on block
            description: Attributes on a block
            source:
                ```(sam)
                    block:(!en-CA)(*id2)(#name)(?a)(?b) Title
                    
                        Content of the block.

            markup:
                block:(?a)(?b)(*id2)(#name)(!en-CA) Title
                    Content of the block.

            result:
                ```(xml)
                    <block conditions="a,b" id="id2" name="name" xml:lang="en-CA">
                    <title>Title</title>
                    <p>Content of the block.</p>
                    </block>

        case: Attributes on field
            description: Attributes on a field
            source:
                ```(sam)
                    field:(!en-CA)(*id3)(#name)(?a)(?b) Value of the field.

            markup:
                field:(?a)(?b)(*id3)(#name)(!en-CA) Value of the field.
            result:
                ```(xml)
                    <field conditions="a,b" id="id3" name="name" xml:lang="en-CA">Value of the field.</field>

        case: Attributes on fragment
            description: Attributes on a fragment
            source:
                ```(sam)
                    ~~~(!en-CA)(*id4)(#name)(?a)(?b)
                    
                        Content of the fragment.

            markup:
                ~~~(?a)(?b)(*id4)(#name)(!en-CA)
                        Content of the fragment.


            result:
                ```(xml)
                    <fragment conditions="a,b" id="id4" name="name" xml:lang="en-CA">
                    <p>Content of the fragment.</p>
                    </fragment>

        case: attributes on grid
            description: Attributes on a grid
            source:
                ```(sam)
                    +++(!en-CA)(*id5)(#name)(?a)(?b)
                    
                        Content | of
                        the     | grid.

            markup:
                +++(?a)(?b)(*id5)(#name)(!en-CA)
                    Content | of
                    the | grid.

            result:
                ```(xml)
                    <grid conditions="a,b" id="id5" name="name" xml:lang="en-CA">
                    <row>
                    <cell>Content</cell>
                    <cell>of</cell>
                    </row>
                    <row>
                    <cell>the</cell>
                    <cell>grid.</cell>
                    </row>
                    </grid>

        case: attributes on record set
            description: Attributes on a record set
            source:
                ```(sam)
                    recordset::(!en-CA)(*id6)(#name)(?a)(?b) foo, bar
                    
                        a, b
                        c, d

            markup:
                recordset::(?a)(?b)(*id6)(#name)(!en-CA)foo, bar
                    a, b
                    c, d
            result:
                ```(xml)
                    <recordset conditions="a,b" id="id6" name="name" xml:lang="en-CA">
                    <record>
                    <foo>a</foo>
                    <bar>b</bar>
                    </record>
                    <record>
                    <foo>c</foo>
                    <bar>d</bar>
                    </record>
                    </recordset>

        case: Attributes on unordered list
            description:
                Attributes on an unordered list item.

            source:
                ```(sam)
                    * Fred
                    
                    *(!en-CA)(*id7)(#name)(?a)(?b) Barney and
                                                   Betty and
                                                   Bam Bam.
                    
                    * Wilma

            markup:
                * Fred

                *(?a)(?b)(*id7)(#name)(!en-CA) Barney and Betty and Bam Bam.

                * Wilma

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="a,b" id="id7" name="name" xml:lang="en-CA">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ul>

        case: Attributes on ordered list
            description:
                Attributes on an ordered list item.

            source:
                ```(sam)
                    1. Fred
                    2.(!en-CA)(*id8)(#name)(?a)(?b) Barney and
                                                    Betty and
                                                    Bam Bam.
                    3. Wilma

            markup:
                1. Fred


                2.(?a)(?b)(*id8)(#name)(!en-CA) Barney and Betty and Bam Bam.


                3. Wilma


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="a,b" id="id8" name="name" xml:lang="en-CA">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ol>

        case: Attributes on labeled list
            description:
                Attributes on a labeled list item.

            source:
                ```(sam)
                    |Do|(#foo7)(?bar)(?green) a deer,
                                              a female deer
                    
                    |Re| a drop of
                         golden sun
                    
                         Is it a particle or a wave?
                    |Me|(*bananas) a name I call myself
                    |Fa| a long long way to run
                    |So| a needle pulling thread
                    |La| a note to follow so
                    |Te| a drink with jam and bread

            markup:
                |Do|(?bar)(?green)(#foo7) a deer, a female deer

                |Re| a drop of golden sun

                   Is it a particle or a wave?

                |Me|(*bananas) a name I call myself

                |Fa| a long long way to run

                |So| a needle pulling thread

                |La| a note to follow so

                |Te| a drink with jam and bread

            result:
                ```(xml)
                    <ll>
                    <li conditions="bar,green" name="foo7">
                    <label>Do</label>
                    <p>a deer, a female deer</p>
                    </li>
                    <li>
                    <label>Re</label>
                    <p>a drop of golden sun</p>
                    <p>Is it a particle or a wave?</p>
                    </li>
                    <li id="bananas">
                    <label>Me</label>
                    <p>a name I call myself</p>
                    </li>
                    <li>
                    <label>Fa</label>
                    <p>a long long way to run</p>
                    </li>
                    <li>
                    <label>So</label>
                    <p>a needle pulling thread</p>
                    </li>
                    <li>
                    <label>La</label>
                    <p>a note to follow so</p>
                    </li>
                    <li>
                    <label>Te</label>
                    <p>a drink with jam and bread</p>
                    </li>
                    </ll>

        case: Attributes on lines
            description:
                Lines with annotations:

            source:
                ```(sam)
                    |(!en-CA)(*id9)(#name)(?a)(?b) You gotta walk that lonesome valley,[*bing page 22]
                    | You gotta walk it by yourself,
                    | Nobody here can walk it for you,
                    |    You gotta walk it by yourself.

            markup:
                |(?a)(?b)(*id9)(#name)(!en-CA) You gotta walk that lonesome valley,[*bing page 22]
                | You gotta walk it by yourself,
                | Nobody here can walk it for you,
                |    You gotta walk it by yourself.
            result:
                ```(xml)
                    <line conditions="a,b" id="id9" name="name" xml:lang="en-CA">You gotta walk that lonesome valley,<citation extra="page 22" idref="bing"/></line>
                    <line>You gotta walk it by yourself,</line>
                    <line>Nobody here can walk it for you,</line>
                    <line>   You gotta walk it by yourself.</line>

        case: Attributes on blockquote
            description:
                A blockquote with attributes and a citation.

            source:
                ```(sam)
                    After this paragraph, there is a blockquote:
                    
                    """(!en-CA)(*id10)(#name)(?a)(?b)[*cit]
                        The quick brown fox jumps over the lazy dog.
                    
                        And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.

            markup:
                After this paragraph, there is a blockquote:

                """(?a)(?b)(*id10)(#name)(!en-CA)[*cit]
                    The quick brown fox jumps over the lazy dog.

                    And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.


            result:
                ```(xml)
                    <p>After this paragraph, there is a blockquote:</p>
                    <blockquote conditions="a,b" id="id10" name="name" xml:lang="en-CA">
                    <citation idref="cit"/>
                    <p>The quick brown fox jumps over the lazy dog.</p>
                    
                    <p>And the <phrase><annotation type="beast" specifically="bovine"><citation value="Mother Goose">cow</citation></annotation></phrase> jumps over the moon.</p>
                    </blockquote>

        case: Attributes on a phrase
            description:
                Attributes on a phrase.

            source:
                ```(sam)
                    {The Duke}(actor "John Wayne")(!en-CA)(*id11)(#name)(?a)(?b)[*cit] plays Rooster Cogburn.

            markup:
                {The Duke}(actor "John Wayne")[*cit](?a)(?b)(*id11)(#name)(!en-CA) plays Rooster Cogburn.

            result:
                ```(xml)
                    <p><phrase conditions="a,b" id="id11" name="name" xml:lang="en-CA"><annotation type="actor" specifically="John Wayne"><citation idref="cit">The Duke</citation></annotation></phrase> plays Rooster Cogburn.</p>

        case: Attributes on a codeblock
            description:
                Attributes on a codeblock.

            source:
                ```(sam)
                    ```(python)(*id12)(#name)(?a)(?b)
                        def escape_for_xml(s):
                            t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                            try:
                                return s.translate(t)
                            except AttributeError:
                                return s

            markup:
                ```(python)(?a)(?b)(*id12)(#name)
                    def escape_for_xml(s):
                        t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s

            result:
                ```(xml)
                    <codeblock conditions="a,b" id="id12" language="python" name="name">
                    def escape_for_xml(s):
                        t = dict(zip([ord('&lt;'), ord('&gt;'), ord('&amp;')], ['&amp;lt;', '&amp;gt;', '&amp;amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s
                    </codeblock>

        case: Attributes on an embed
            description:
                Attributes on a embed.

            source:
                ```(sam)
                    ```(=latexmathml)(*id14)(#name)(?a)(?b)
                        n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            markup:
                ```(=latexmathml)(?a)(?b)(*id14)(#name)
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            result:
                ```(xml)
                    <embedblock conditions="a,b" encoding="latexmathml" id="id14" name="name">
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k
                    </embedblock>

        case: Attributes on inserts
            description:
                Attributes on inserts.

            source:
                ```(sam)
                    >>>(image foo.gif)(*id15)(#name)(?a)(?b)

            markup:
                >>>(image foo.gif)(?a)(?b)(*id15)(#name)

            result:
                ```(xml)
                    <insert conditions="a,b" id="id15" item="foo.gif" name="name" type="image"/>

        case: Attributes on inserts
            description:
                Attributes on inserts.

            source:
                ```(sam)
                    >>>(image bar.png)(#baz)

            markup:
                >>>(image bar.png)(#baz)

            result:
                ```(xml)
                    <insert item="bar.png" name="baz" type="image"/>

    test: Annotations
        description:
            A phrase can have one or more annotations or citations attached to it. On output, the text of the phrase is wrapped in the annotations and citations in the order they were specified in source.

        case: Multiple annotations
            description:
                Phrases with more than one attribute in a chain.

            source:
                ```(sam)
                    This is {very}(bold) important.
                    
                    This is {very}(bold)(italic) important.
                    
                    This is {very}(bold)(italic)(green) important.
                    
                    This `foo`(bar) baz.

            markup:
                This is {very}(bold) important.

                This is {very}(bold)(italic) important.

                This is {very}(bold)(italic)(green) important.

            result:
                ```(xml)
                    <p>This is <phrase><annotation type="bold">very</annotation></phrase> important.</p>
                    <p>This is <phrase><annotation type="bold"><annotation type="italic">very</annotation></annotation></phrase> important.</p>
                    <p>This is <phrase><annotation type="bold"><annotation type="italic"><annotation type="green">very</annotation></annotation></annotation></phrase> important.</p>

        case: Consecutive Annotations
            description:
                Two separate annotations with no space between them.

            source:
                ```(sam)
                    {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            markup:
                {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            result:
                ```(xml)
                    <p><phrase><annotation type="actor" specifically="John Wayne"><annotation type="if" specifically="1969">The Duke</annotation></annotation></phrase><phrase><annotation type="actor"><annotation type="if" specifically="2010">Jeff Bridges</annotation></annotation></phrase> plays Rooster Cogburn.</p>

        case: Consecutive Annotations on decorations
            description:
                Two separate annotations with no space between them.

            source:
                ```(sam)
                    {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            markup:
                {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            result:
                ```(xml)
                    <p><phrase><annotation type="actor" specifically="John Wayne"><annotation type="if" specifically="1969">The Duke</annotation></annotation></phrase><phrase><annotation type="actor"><annotation type="if" specifically="2010">Jeff Bridges</annotation></annotation></phrase> plays Rooster Cogburn.</p>

        case: Annotation followed by citation
            description:
                Observed in the wild: When an annotated phrase was followed by a phrase with a citation, the end of the annotation was not found and the two structures were recognized as one long citation.

            source:
                ```(sam)
                    When using the map approach, it is important to
                    think about how your content will {single
                    source}(concept "single sourcing") to paper-like
                    media and hypertext-media. Some people will output
                    the same map to to both media. In hyper-text media
                    that usually results in the map being turned into
                    a table of contents, often displayed in a separate
                    pane as in a help system. This may be fine if you
                    are creating a help system, but it is not how Web
                    content is usually displayed. Another approach to
                    single sourcing content that uses the assemble from
                    pieces approach is to create completely separate maps
                    -- or even to use completely different assembly
                    techniques that don't involve maps at all -- to produce
                    paper-like and hypertext outputs. This can help you
                    to work around some of the design limitations that
                    we talked about in the {single sourcing
                    chapter}[#single_source].

            markup:
                When using the map approach, it is important to think about how your content will {single source}(concept "single sourcing") to paper-like media and hypertext-media. Some people will output the same map to to both media. In hyper-text media that usually results in the map being turned into a table of contents, often displayed in a separate pane as in a help system. This may be fine if you are creating a help system, but it is not how Web content is usually displayed. Another approach to single sourcing content that uses the assemble from pieces approach is to create completely separate maps – or even to use completely different assembly techniques that don’t involve maps at all – to produce paper-like and hypertext outputs. This can help you to work around some of the design limitations that we talked about in the {single sourcing chapter}[#single_source].

            result:
                ```(xml)
                    <p>When using the map approach, it is important to think about how your content will <phrase><annotation type="concept" specifically="single sourcing">single source</annotation></phrase> to paper-like media and hypertext-media. Some people will output the same map to to both media. In hyper-text media that usually results in the map being turned into a table of contents, often displayed in a separate pane as in a help system. This may be fine if you are creating a help system, but it is not how Web content is usually displayed. Another approach to single sourcing content that uses the assemble from pieces approach is to create completely separate maps – or even to use completely different assembly techniques that don’t involve maps at all – to produce paper-like and hypertext outputs. This can help you to work around some of the design limitations that we talked about in the <phrase><citation nameref="single_source">single sourcing chapter</citation></phrase>.</p>

        case: Annotation with language metadata
            description:
                You can add language metadata to a phrase.

            source:
                ```(sam)
                    Press {Enter}(key)(!fr-CA)

            markup:
                Press {Enter}(key)(!fr-CA)

            result:
                ```(xml)
                    <p>Press <phrase xml:lang="fr-CA"><annotation type="key">Enter</annotation></phrase></p>

        case: Annotation with a condition
            description:
                You can add condition metadata to a phrase.

            source:
                ```(sam)
                    Press {Enter}(key)(?foo)

            markup:
                Press {Enter}(key)(?foo)

            result:
                ```(xml)
                    <p>Press <phrase conditions="foo"><annotation type="key">Enter</annotation></phrase></p>

        case: Prior annotation lookup
            description:
                If a phrase has no annotation or citation attached to it, the parser will attempt to find a suitable annotation by searching back up the document for the most recent case of the same phrase. If it finds one, it will copy the annotations and citations from that phrase to the current one. This prevents writers from having to write the same annotation out over and over again. If not prior phrase is found, a warning is issued.

            source:
                ```(sam)
                    This {annotation}(https://en.wikipedia.org/wiki/Annotation) is repeated {annotation}.

            markup:
                This {annotation}(link "https://en.wikipedia.org/wiki/Annotation") is repeated {annotation}(link "https://en.wikipedia.org/wiki/Annotation").

            result:
                ```(xml)
                    <p>This <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></phrase> is repeated <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></phrase>.</p>

        case: Case insensitive lookup
            description:
                Annotation lookup is case insensitive unless the annotation-lookup declaration is set to `case sensitive`.

            source:
                ```(sam)
                    This {annotation}(https://en.wikipedia.org/wiki/Annotation) is repeated {Annotation}.

            markup:
                This {annotation}(link "https://en.wikipedia.org/wiki/Annotation") is repeated {Annotation}(link "https://en.wikipedia.org/wiki/Annotation").

            result:
                ```(xml)
                    <p>This <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></phrase> is repeated <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">Annotation</annotation></phrase>.</p>

        case: Case insensitive lookup with multiple annotations
            description:
                Make sure all annotations are copied

            source:
                ```(sam)
                    This {annotation}(foo)(https://en.wikipedia.org/wiki/Annotation) is repeated {Annotation}.

            markup:
                This {annotation}(foo)(link "https://en.wikipedia.org/wiki/Annotation") is repeated {Annotation}(foo)(link "https://en.wikipedia.org/wiki/Annotation").

            result:
                ```(xml)
                    <p>This <phrase><annotation type="foo"><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></annotation></phrase> is repeated <phrase><annotation type="foo"><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">Annotation</annotation></annotation></phrase>.</p>

        case: Prior annotation lookup in included file
            description:
                Look up annotations in included files.

            source:
                ```(sam)
                    Annotation lookup test: {test phrase}.

            markup:
                Annotation lookup test: {test phrase}(test).

            result:
                ```(xml)
                    <p>Annotation lookup test: <phrase><annotation type="test">test phrase</annotation></phrase>.</p>

        case: Earlier para
            description:
                The marching annotation is in an earlier paragraph in the document. (In this case, in the preceding test case).

            source:
                ```(sam)
                    This {annotation} occurs previously.

            markup:
                This {annotation}(foo)(link "https://en.wikipedia.org/wiki/Annotation") occurs previously.

            result:
                ```(xml)
                    <p>This <phrase><annotation type="foo"><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></annotation></phrase> occurs previously.</p>

        case: Failure
            description:
                There is no previous phrase. This should generate a warning when the test is run.

            source:
                ```(sam)
                    This {should be reported}.

            markup:
                This {should be reported}.

            result:
                ```(xml)
                    <p>This <phrase>should be reported</phrase>.</p>

        case: Local only annotations
            description:
                A local-only annotation is one which applies only to the current phrase. It is not taken into consideration in annotation lookup, so the lookup search will proceed to the next phrase with the same text. Annotation lookup will occur for a phrase with a local-only annotation, and the local annotation will be added to the looked up annotations, if any.

            source:
                ```(sam)
                    Testing {XML}(language) testing {XML}+(index) testing {XML}+(language).

            markup:
                Testing {XML}(language) testing {XML}(index)(language) testing {XML}(language).

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="language">XML</annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

        case: Attribute annotations
            description:
                Attributes like ID should not be copied because they are supposed to be unique.

            source:
                ```(sam)
                    Testing {XML}+(*foot) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}(language)(*foot) testing {XML}(index)(language) testing {XML}(language).

            result:
                ```(xml)
                    <p>Testing <phrase id="foot"><annotation type="language">XML</annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

        case: Mix of local and global
            description:
                A mix of local and global annotations.

            source:
                ```(sam)
                    Testing {XML}+(foo)(language) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}(foo)(language) testing {XML}(index)(language) testing {XML}(language).

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="foo"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

        case: Multiple local
            description:
                Multiple local annotations.

            source:
                ```(sam)
                    Testing {XML}+(foobar)+(verbiage) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}(foobar)(verbiage)(language) testing {XML}(index)(language) testing {XML}(language).

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="foobar"><annotation type="verbiage"><annotation type="language">XML</annotation></annotation></annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

    test: Decorations
        description:
            A decoration is a shortcut for a {media domain}(concept) annotation. Three decorations are supported, bold, italic, and code.

        case: Bold, italic, and code
            description:
                One test case for all decorations.

            source:
                ```(sam)
                    This sentence contains decorations for *bold*, _italic_, and `code`.

            markup:
                This sentence contains decorations for {bold}(bold), {italic}(italic), and `code`.

            result:
                ```(xml)
                    <p>This sentence contains decorations for <phrase><annotation type="bold">bold</annotation></phrase>, <phrase><annotation type="italic">italic</annotation></phrase>, and <code>code</code>.</p>

        case: Unbalanced decorations and escapes
            description:
                Unbalanced decorations and escapes

            source:
                ```(sam)
                    In Rio Bravo, \*the \`Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays *an ex-Union colonel `out for revenge.

            markup:
                In Rio Bravo, \*the \`Duke (see: https://en.wikipedia.org/wiki/John\_Wayne) plays \*an ex-Union colonel \`out for revenge.

            result:
                ```(xml)
                    <p>In Rio Bravo, *the `Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays *an ex-Union colonel `out for revenge.</p>

    test: Inline code
        description:
            Inline code is a form of phrase used for phrases that are in computer languages or other encodings other than the human language of the text.

        case: Inline latexmath
            description:
                A selection of latex math to be printed.

            source:
                ```(sam)
                    This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(latexmath)(!en) in the middle of a paragraph. 

            markup:
                This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(latexmath)(!en) in the middle of a paragraph.

            result:
                ```(xml)
                    <p>This is an equation <code language="latexmath" xml:lang="en">\frac{ \sum_{t=0}^{N}f(t,k) }{N}</code> in the middle of a paragraph.</p> 

        case: Embedded latexmath
            description:
                A selection of latex math to be embedded as an equation.

            source:
                ```(sam)
                    This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(=latexmath) in the middle of a paragraph.

            markup:
                This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(=latexmath) in the middle of a paragraph.

            result:
                ```(xml)
                    <p>This is an equation <embed encoding="latexmath">\frac{ \sum_{t=0}^{N}f(t,k) }{N}</embed> in the middle of a paragraph.</p> 

    test: Links
        description:
            Links are created with an annotation.

            You can specify a link as a `link` annotation.

            ```
                foo {bar}(link "http://example.com/bar") baz

            The link annotation shortcut lets you shorten this to:

            ```
                foo {bar}(http://example.com/bar) baz

            However, use of the shortcut means you need to escape any parens that occur in the URL.

        case: Parens not escaped
            description:
                The parens are not escaped, causing misreading of markup. This example should be interpreted incorrectly.

            source:
                ```(sam)
                    Rio Bravo refers to the movie
                    (and not to {the city in Texas or
                    the nature reserve in
                    Belize}(https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)))

            markup:
                Rio Bravo refers to the movie (and not to {the city in Texas or the nature reserve in Belize}(link "https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_" (disambiguation)))

            result:
                ```(xml)
                    <p>Rio Bravo refers to the movie (and not to <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_" namespace="disambiguation">the city in Texas or the nature reserve in Belize</annotation></phrase>)</p>

        case: Parens escaped with backslashes
            description:
                The parens in the URL are escaped with blackslashes. This example should be interpreted correctly.

            source:
                ```(sam)
                    Rio Bravo refers to the movie
                    (and not to {the city in Texas or
                    the nature reserve in
                    Belize}(https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_\(disambiguation\)))

            markup:
                Rio Bravo refers to the movie (and not to {the city in Texas or the nature reserve in Belize}(link "https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)"))

            result:
                ```(xml)
                    <p>Rio Bravo refers to the movie (and not to <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)">the city in Texas or the nature reserve in Belize</annotation></phrase>)</p>

        case: Using explicit link annotation instead of shortcut
            description:
                The link is specified using a specific link annotation so the URL is not in parens itself. This example should be interpreted correctly.

            source:
                ```(sam)
                    Rio Bravo refers to the movie
                    (and not to {the city in Texas or
                    the nature reserve in
                    Belize}(link "https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)"))

            markup:
                Rio Bravo refers to the movie (and not to {the city in Texas or the nature reserve in Belize}(link "https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)"))

            result:
                ```(xml)
                    <p>Rio Bravo refers to the movie (and not to <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)">the city in Texas or the nature reserve in Belize</annotation></phrase>)</p>

    test: Citations
        description:
            A citation is a reference to a source of information. You can cite with a phrase or by reference to an ID or a name.

        case: Citation on phrase
            description:
                A citation on a phrase

            source:
                ```(SAM)
                    You can {call me Ishmael}[Melville, 1851][Daffy, 2017][%key.bar12 page 22].

            markup:
                You can {call me Ishmael}[Melville, 1851][Daffy, 2017][%key.bar12 page 22].

            result:
                ```(XML)
                    <p>You can <phrase><citation value="Melville, 1851"><citation value="Daffy, 2017"><citation extra="page 22" keyref="key.bar12">call me Ishmael</citation></citation></citation></phrase>.</p>

        case: Citation and annotation on one phrase
            description:
                A citation on a phrase that also has an annotation.

            source:
                ```(SAM)
                    You can {call me Ishmael}(quote)[Melville, 1851].

            markup:
                You can {call me Ishmael}(quote)[Melville, 1851].

            result:
                ```(XML)
                    <p>You can <phrase><annotation type="quote"><citation value="Melville, 1851">call me Ishmael</citation></annotation></phrase>.</p>

        case: Citations with compound identifiers
            description:
                A citation using a compound identifier (a name reference and an id reference) with extra text.

            source:
                ```(SAM)
                    You can {call me Ishmael}[#Melville/*MobyDick page 1].

            markup:
                You can {call me Ishmael}[#Melville/*MobyDick page 1].

            result:
                ```(XML)
                    <p>You can <phrase><citation extra="page 1"><reference-elements><reference-element method="nameref" value="Melville"/><reference-element method="idref" value="MobyDick"/></reference-elements>call me Ishmael</citation></phrase>.</p>

        case: Literal square brackets
            description:
                If you want to enter literal square brackets, rather than create a citation, escape the opening square bracket with a backslash.

            source:
                ```(sam)
                    Press \[Enter].

            markup:
                Press \[Enter].

            result:
                ```(xml)
                    <p>Press [Enter].</p>

        case: Multiple citations is a paragraph
            description:
                 Making sure that when there are multiple citations in a paragraph they are all detected separately.

            source:
                 ```(sam)
                    Among its default processing steps, the SPFE process includes the subject-based linking algorithms described in [#chapter.linking] and the subject-based composition and architecture algorithms described in [#chapter.composition] and [#chapter.architecture], including bottom-up information architecture.

            markup:
                Among its default processing steps, the SPFE process includes the subject-based linking algorithms described in [#chapter.linking] and the subject-based composition and architecture algorithms described in [#chapter.composition] and [#chapter.architecture], including bottom-up information architecture.

            result:
                ```(xml)
                    <p>Among its default processing steps, the SPFE process includes the subject-based linking algorithms described in <citation nameref="chapter.linking"/> and the subject-based composition and architecture algorithms described in <citation nameref="chapter.composition"/> and <citation nameref="chapter.architecture"/>, including bottom-up information architecture.</p>

    test: Characters
        description:
            All SAM documents are UTF-8 unicode documents. Therefore you should be able to enter any character directly. However, typing extended characters is not easy, so SAM supports character entities for entering characters that are not easy to type.

        case: HTML named entities
            description:
                All of the HTML named character entities are supported.

            source:
                ```(sam)
                    The doggy in the window costs &pound;5.00.

            markup:
                The doggy in the window costs £5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs £5.00.</p>

        case: Numeric entities
            description:
                XML-style decimal numeric character entities are supported.

            source:
                ```(sam)
                    The doggy in the window costs &#163;5.00.

            markup:
                The doggy in the window costs £5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs £5.00.</p>

        case: Hexadecimal entity
            description:
                XML-style hexadecimal numeric character entities are supported.

            source:
                ```(sam)
                    The doggy in the window costs &#xA3;5.00.

            markup:
                The doggy in the window costs £5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs £5.00.</p>

        case: Character entities inside phrases and decorations
            description:
                Make sure entities are recognized in phrases and decorations.

            source:
                ```(sam)
                    The doggy in the window costs *&#xA3;*5.00.
                    
                    The doggy in the window costs {&#xA3;5.00}(money).

            markup:
                The doggy in the window costs {£}(bold)5.00.

                The doggy in the window costs {£5.00}(money).

            result:
                ```(xml)
                    <p>The doggy in the window costs <phrase><annotation type="bold">£</annotation></phrase>5.00.</p>
                    <p>The doggy in the window costs <phrase><annotation type="money">£5.00</annotation></phrase>.</p>

        case: In code annotation shortcut:
            description:
                In a code decoration, character entities are not expanded.

            source:
                ```(sam)
                    The doggy in the window costs `&#xA3;`5.00.

            markup:
                The doggy in the window costs `&#xA3;`5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs <code>&amp;#xA3;</code>5.00.</p>

        case: In bold decoration escaped:
            description:
                Escaped version inside a bold decoration.

            source:
                ```(sam)
                    The doggy in the window costs *\&#xA3;*5.00.

            markup:
                The doggy in the window costs {\&#xA3;}(bold)5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs <phrase><annotation type="bold">&amp;#xA3;</annotation></phrase>5.00.</p>

        case: Ampersand in a sentence, escaped with \\ and not escaped.
            description:
                Unlike XML, SAM does not require that an ampersand be escaped if it is not part of a character entity. You can escape it if you want to using a backslash. Both should output in XML as `&amp;`

            source:
                ```(sam)
                    The cat & the dog.
                    
                    The cat \& the dog.

            markup:
                The cat \& the dog.

                The cat \& the dog.

            result:
                ```(xml)
                    <p>The cat &amp; the dog.</p>
                    <p>The cat &amp; the dog.</p>

    test: Character escapes
        description:
            Character escaping

        case: Escapes in explicit annotations
            description:
                Escaping curly braces and backslashes inside a phrase.

            source:
                ```(sam)
                    There is a curly brace and two backslashes in {this \\\\\{ phrase}(bold).

            markup:
                There is a curly brace and two backslashes in {this \\\\\{ phrase}(bold).

            result:
                ```(xml)
                    <p>There is a curly brace and two backslashes in <phrase><annotation type="bold">this \\{ phrase</annotation></phrase>.</p>

        case: Escapes in code decorations
            description:
                Code decorations have different escaping rules. All characters are literal except that the backtick character can be escaped with a double back tick. Character entities are not translated in a code decoration. Smart quote transformations are not applied.

            source:
                ```(sam)
                    There is a backtick and two backslashes in `th\\is `` code` decoration.
                    
                    There is a backslash and a curly brace in `this \{ code` decoration.
                    
                    `pubwork="book"` is an attribute on the element `citetitle`.

            markup:
                There is a backtick and two backslashes in `th\\is `` code` decoration.

                There is a backslash and a curly brace in `this \{ code` decoration.

                `pubwork="book"` is an attribute on the element `citetitle`.

            result:
                ```(xml)
                    <p>There is a backtick and two backslashes in <code>th\\is ` code</code> decoration.</p>
                    <p>There is a backslash and a curly brace in <code>this \{ code</code> decoration.</p>
                    <p><code>pubwork="book"</code> is an attribute on the element <code>citetitle</code>.</p>

        case: Escapes in decorations
            description:
                Escape sequences are recognized inside decorations.

            source:
                ```(sam)
                    There is a `*` in *this \* bold* decoration.
                    
                    There is a `_` in _this \_ italic_ decoration.

            markup:
                There is a `*` in {this \* bold}(bold) decoration.

                There is a `_` in {this \_ italic}(italic) decoration.

            result:
                ```(xml)
                    <p>There is a <code>*</code> in <phrase><annotation type="bold">this * bold</annotation></phrase> decoration.</p>
                    <p>There is a <code>_</code> in <phrase><annotation type="italic">this _ italic</annotation></phrase> decoration.</p>

        case: XML reserved characters in citation specifically attribute
            description:
                XML reserved characters occurring within the text of a “specifically” attribute.

            source:
                ```(sam)
                    {Skimbleshanks}(animal '"Old  <>& Possum"' (Eliott)).

            markup:
                {Skimbleshanks}(animal "\"Old  <>& Possum\"" (Eliott)).

            result:
                ```(xml)
                    <p><phrase><annotation type="animal" specifically="&quot;Old  &lt;&gt;&amp; Possum&quot;" namespace="Eliott">Skimbleshanks</annotation></phrase>.</p>

    test: Conditions
        description:
            You can add conditions to block metadata using condition tokens. Condition tokens start with `?` and must not contain spaces. The application of conditions to text is up to the application layer. SAM just provided a mechanism for recording conditions.

        case: Conditions on unordered list shortcut
            description:
                A condition on an unordered list item.

            source:
                ```(sam)
                    * Fred
                    
                    *(?foo) Barney and
                            Betty and
                            Bam Bam.
                    
                    * Wilma

            markup:
                * Fred

                *(?foo) Barney and Betty and Bam Bam.

                * Wilma

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="foo">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ul>

        case: Conditions on ordered list shortcut
            description:
                Condition on an ordered list item.

            source:
                ```(sam)
                    1. Fred
                    2.(?foo) Barney and
                             Betty and
                             Bam Bam.
                    3. Wilma

            markup:
                1. Fred


                2.(?foo) Barney and Betty and Bam Bam.


                3. Wilma


            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="foo">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ol>

    test: Block inserts
        description:
            An insert creates an instruction to insert something into the document.

        case: Image insert
            description:
                Insert an image.

            source:
                ```(sam)
                    >>>(image foo.gif)(?goo)

            markup:
                >>>(image foo.gif)(?goo)

            result:
                ```(xml)
                    <insert conditions="goo" item="foo.gif" type="image"/>

        case: Insert by ID
            description:
                Insert an object by ID.

            source:
                ```(sam)
                    section:(*id99)
                        Hello Mars!
                    >>>(*id99)

            markup:
                    section:(*id99)
                        Hello Mars!

                    >>>(*id99)

            result:
                ```(xml)
                    <section id="id99">
                    <p>Hello Mars!</p>
                    </section>
                    <insert idref="id99"/>

        case: Key insert
            description:
                Insert the value of a key. Syntax for creating keys is left to the language designer. Key resolution belongs to the application layer.

            source:
                ```(sam)
                    >>>(%glug)

            markup:
                >>>(%glug)

            result:
                ```(xml)
                    <insert keyref="glug"/>

    test: Inline inserts
        description:
            Inline inserts are an instructions to insert something into the middle of a paragraph.

        case: Inline inserts
            description:
                Inline inserts.

            source:
                ```(sam)
                    Because you often want to >(image "circle.png")(*circle)(?baz)(?bat) change some part of a text when it is being
                    reused, <fragments> & fragment references can both define local {strings}(feature).
                    Any {string references}(feature) inside a fragment will be resolved by looking first
                    at local-strings defined in the >(*my-table) fragment reference, then at local strings defined
                    in the fragment definition, and then at global strings. In effect, this means
                    that you can define string substitutions whenever you insert a fragment into your content.

            markup:
                Because you often want to >(image circle.png)(?baz)(?bat)(*circle) change some part of a text when it is being reused, <fragments> \& fragment references can both define local {strings}(feature). Any {string references}(feature) inside a fragment will be resolved by looking first at local-strings defined in the >(*my-table) fragment reference, then at local strings defined in the fragment definition, and then at global strings. In effect, this means that you can define string substitutions whenever you insert a fragment into your content.

            result:
                ```(xml)
                    <p>Because you often want to <inline-insert conditions="baz,bat" id="circle" item="circle.png" type="image"/> change some part of a text when it is being reused, &lt;fragments&gt; &amp; fragment references can both define local <phrase><annotation type="feature">strings</annotation></phrase>. Any <phrase><annotation type="feature">string references</annotation></phrase> inside a fragment will be resolved by looking first at local-strings defined in the <inline-insert idref="my-table"/> fragment reference, then at local strings defined in the fragment definition, and then at global strings. In effect, this means that you can define string substitutions whenever you insert a fragment into your content.</p>

        case: Inline insert by ID
            description:
                Inline insert by ID of an inline element. This is mostly for testing HTML output mode which tries to resolve these.

            source:
                ```(sam)
                    There is a circle >(*circle) in this sentence.

                    >>>(*circle)

            markup:
                There is a circle >(*circle) in this sentence.

                >>>(*circle)

            result:
                ```(xml)
                    <p>There is a circle <inline-insert idref="circle"/> in this sentence.</p>
                    <insert idref="circle"/>

        case: Paragraph that is just an inline insert
            description:
                An inline insert on a line by itself creates a paragraph containing an insert, rather than a standalone insert instruction.

            source:
                ```(sam)
                    >(#foo8)

            markup:
                >(#foo8)

            result:
                ```(xml)
                    <p><inline-insert nameref="foo8"/></p>

    test: Strings
        description:
            A string is a variable that can contain text, including annotations and citations.

        case: String definition
            description:
                A string definition.

            source:
                ```(sam)
                    $foo = bar bar black sheep

            markup:
                $foo=bar bar black sheep
            result:
                ```(xml)
                    <variable name="foo">bar bar black sheep</variable>

        case: String references
            $foo=bar bar black sheep
            description:
                Inserting the value of a string.

            source:
                ```(sam)
                    $foo = bar bar green sheep
                    This sentence includes a string reference >($foo).

            markup:
                $foo=bar bar black sheep
                This sentence includes a string reference >($foo).

            result:
                ```(xml)
                   <variable name="foo">bar bar black sheep</variable>
                   <p>This sentence includes a string reference <inline-insert variableref="foo"/>.</p>

        case: String lookup
            description:
                This is a test for HTML output mode string lookup. It should be moved to a different test doc.

            source:
                ```(sam)
                    $str = One
                    $str = Un
                    section:(#section.foo) foo
                        $str = Two
                    
                        This sentence should end with the word for 2: >($str)
                    
                        $str = Four
                    
                    section: bar
                        This sentence should end with the word for 1: >($str)
                    
                        #$str = Six
                    
                    >>>(#section.foo)
                        $str = Deux
                    
                    $str = Five

            markup:
                $str=One
                $str=Un
                section:(#section.foo) foo
                    $str=Two
                    This sentence should end with the word for 2: >($str)

                    $str=Four
                section: bar
                    This sentence should end with the word for 1: >($str)

                    #$str = Six
                >>>(#section.foo)
                    $str=Deux

                $str=Five
            result:
                ```(xml)
                    <variable name="str">One</variable>
                    <variable name="str">Un</variable>
                    <section name="section.foo">
                    <title>foo</title>
                    <variable name="str">Two</variable>
                    <p>This sentence should end with the word for 2: <inline-insert variableref="str"/></p>
                    <variable name="str">Four</variable>
                    </section>
                    <section>
                    <title>bar</title>
                    <p>This sentence should end with the word for 1: <inline-insert variableref="str"/></p>
                    </section>
                    <insert nameref="section.foo">
                    <variable name="str">Deux</variable>
                    </insert>
                    <variable name="str">Five</variable>

    test: Fragments
        description:
            Fragments are sequences of paragraphs that can have management metadata applied to them and that can be inserted in other places.

        case: Fragment
            description:
                A fragment definition.

            source:
                ```(sam)
                    ~~~(#foo3)(?gruz-natz)
                        $a=apple
                        $b=banana
                    
                        This is a sentence inside a fragment.
                    
                        ~~~(#gruznatz)
                            $p=peach
                    
                            This is a nested fragment.

            markup:
                ~~~(?gruz-natz)(#foo3)
                    $a=apple
                    $b=banana
                    This is a sentence inside a fragment.

                    ~~~(#gruznatz)
                        $p=peach
                        This is a nested fragment.



            result:
                ```(xml)
                    <fragment conditions="gruz-natz" name="foo3">
                    <variable name="a">apple</variable>
                    <variable name="b">banana</variable>
                    <p>This is a sentence inside a fragment.</p>
                    <fragment name="gruznatz">
                    <variable name="p">peach</variable>
                    <p>This is a nested fragment.</p>
                    </fragment>
                    </fragment>

        case: Insert a fragment
            description:
                An instruction to insert a fragment. Note that actually resolving and inserting the fragment is a job for the application layer.

            source:
                ```(sam)
                    >>>(#fragment.foobar)
                        $a=apricot
                        $b=breadfruit

            markup:
                >>>(#fragment.foobar)
                    $a=apricot
                    $b=breadfruit

            result:
                ```(xml)
                    <insert nameref="fragment.foobar">
                    <variable name="a">apricot</variable>
                    <variable name="b">breadfruit</variable>
                    </insert>

    test: Smart quotes
        description:
            Smart quotes is an optional feature of the parser, not a feature of the SAM language. It turns straight quotes into curly quotes. It raises a warning when it can’t figure out how to handle a case. The algorithm could be improved in the future to handle more cases correctly.

            The canonical way to handle quotes in SAM is to use real curly quotes to begin with. All SAM documents are UTF-8.

            Note: These tests will fail if smart quotes is not selected
            using the `-q` option of the parser command line or by setting the `smart_quotes` attribute of the SamParser object to `True`.

        case: Smart quotes
            description:
                Paragraphs illustrating most of the cases where smart quotes should be recognized in ordinary English.

            source:
                ```(sam)
                    "For once, 'sir' adding, 'you're making a
                    scene.'" and "For once, 'sir' adding,
                    'you're making a scene.'" In the winter
                    of ’65. "Yes," he said, "I met her. She's
                    very 'friendly.'" '"I don’t know what you
                    mean by 'glory,'" Alice said.' "'I don’t
                    know what you mean by "glory,"' Alice said."
                    
                    For "the Duke", perhaps?

            markup:
                “For once, ‘sir’ adding, ‘you’re making a scene.’” and “For once, ‘sir’ adding, ‘you’re making a scene.’” In the winter of ’65. “Yes,” he said, “I met her. She’s very ‘friendly.’” ‘“I don’t know what you mean by ‘glory,’” Alice said.’ “‘I don’t know what you mean by “glory,”’ Alice said.”

                For “the Duke”, perhaps?

            result:
                ```(xml)
                    <p>“For once, ‘sir’ adding, ‘you’re making a scene.’” and “For once, ‘sir’ adding, ‘you’re making a scene.’” In the winter of ’65. “Yes,” he said, “I met her. She’s very ‘friendly.’” ‘“I don’t know what you mean by ‘glory,’” Alice said.’ “‘I don’t know what you mean by “glory,”’ Alice said.”</p>
                    <p>For “the Duke”, perhaps?</p>

        case: Following an annotation
            description:
                Smart quotes also need to be recognized when they follow SAM markup.

            source:
                ```(sam)
                    interpretations of the `xref`'s instruction

            markup:
                interpretations of the `xref`’s instruction

            result:
                ```(xml)
                    <p>interpretations of the <code>xref</code>’s instruction</p>

        case: Smart quotes with annotations
            description:
                Smart quotes surrounding annotated phrases.

            source:
                ```(sam)
                    "For once, '{sir}(salutation)' adding, 'you're making a
                    scene.'" and "For once, {'sir'}(salutation) adding,
                    'you're making a scene.'" In the winter
                    of ’65. "Yes," he said, "I met her. She's
                    very 'friendly.'" '"I don’t know what you
                    mean by 'glory,'" Alice said.' "'I don’t
                    know what you mean by "glory,"' Alice said."

            markup:
                “For once, ‘{sir}(salutation)’ adding, ‘you’re making a scene.’” and “For once, {‘sir’}(salutation) adding, ‘you’re making a scene.’” In the winter of ’65. “Yes,” he said, “I met her. She’s very ‘friendly.’” ‘“I don’t know what you mean by ‘glory,’” Alice said.’ “‘I don’t know what you mean by “glory,”’ Alice said.”

            result:
                ```(xml)
                    <p>“For once, ‘<phrase><annotation type="salutation">sir</annotation></phrase>’ adding, ‘you’re making a scene.’” and “For once, <phrase><annotation type="salutation">‘sir’</annotation></phrase> adding, ‘you’re making a scene.’” In the winter of ’65. “Yes,” he said, “I met her. She’s very ‘friendly.’” ‘“I don’t know what you mean by ‘glory,’” Alice said.’ “‘I don’t know what you mean by “glory,”’ Alice said.”</p>

        case: Adjacent to parentheses
            description:
                Quotes inside parentheses.

            source:
                ```(sam)
                    A vector graphic program creates graphics as a collection of  objects ("vector" meaning the mathematical representation of a shape or line).
                    
                    The shape of the characters (technically, "glyphs") that make up the font are stored separately in font files.

            markup:
                A vector graphic program creates graphics as a collection of  objects (“vector” meaning the mathematical representation of a shape or line).

                The shape of the characters (technically, “glyphs”) that make up the font are stored separately in font files.

            result:
                ```(xml)
                    <p>A vector graphic program creates graphics as a collection of  objects (“vector” meaning the mathematical representation of a shape or line).</p>
                    <p>The shape of the characters (technically, “glyphs”) that make up the font are stored separately in font files.</p>

        case: Close quote followed by citation.
            description:
                Close quote followed by citation.

            source:
                ```(sam)
                    "What is truth?"[John 18:38]

            markup:
                “What is truth?”[John 18:38]

            result:
                ```(xml)
                    <p>“What is truth?”<citation value="John 18:38"/></p>

        case: Miscellaneous cases
            description:
                A bunch of miscellaneous cases.

            source:
                ```(sam)
                    "title"?
                    
                    {DocBook}(language)'s
                    
                    {DITA}(language) and {DocBook}'s

            markup:
                “title”?

                {DocBook}(language)’s

                {DITA}(language) and {DocBook}(language)’s

            result:
                ```(xml)
                    <p>“title”?</p>
                    <p><phrase><annotation type="language">DocBook</annotation></phrase>’s</p>
                    <p><phrase><annotation type="language">DITA</annotation></phrase> and <phrase><annotation type="language">DocBook</annotation></phrase>’s</p>

        case: Escaped dumb quotes
            description:
                If you want to enter straight quotes and have them stay straight when smart quotes are applied, you have to escape them with `\` or use the `&quot;` character entity.

            source:
                ```(sam)
                    This para uses \"dumb\" quotes. Don\'t get them &quot;mixed up&quot;.

            markup:
                This para uses "dumb" quotes. Don't get them "mixed up".

            result:
                ```(xml)
                    <p>This para uses "dumb" quotes. Don't get them "mixed up".</p>

        case: Em and en dashes
            description:
                The smart quote feature will also transform double hyphens surrounded by spaces and triple hyphens surrounded by letters into en and em dashes respectively.

            source:
                ```(sam)
                    This para contains -- an en dash and an---em dash.
                    
                    This para contains -- {an}(word) en dash and an---{em}(word) dash.
                    
                    This para {contains}(word) -- an en dash and {an}(word)---em dash.
                    
                    This para *contains* -- an en dash and _an_---em dash.
                    
                    This para `contains` -- an en dash and "an"---em dash.
                    
                    This para 'contains' -- an en dash and `an`---em dash.
                    
                    x, y, z, etc. -- something else

            markup:
                This para contains – an en dash and an—em dash.

                This para contains – {an}(word) en dash and an—{em}(word) dash.

                This para {contains}(word) – an en dash and {an}(word)—em dash.

                This para {contains}(bold) – an en dash and {an}(italic)—em dash.

                This para `contains` – an en dash and “an”—em dash.

                This para ‘contains’ – an en dash and `an`—em dash.

                x, y, z, etc. – something else

            result:
                ```(xml)
                    <p>This para contains – an en dash and an—em dash.</p>
                    <p>This para contains – <phrase><annotation type="word">an</annotation></phrase> en dash and an—<phrase><annotation type="word">em</annotation></phrase> dash.</p>
                    <p>This para <phrase><annotation type="word">contains</annotation></phrase> – an en dash and <phrase><annotation type="word">an</annotation></phrase>—em dash.</p>
                    <p>This para <phrase><annotation type="bold">contains</annotation></phrase> – an en dash and <phrase><annotation type="italic">an</annotation></phrase>—em dash.</p>
                    <p>This para <code>contains</code> – an en dash and “an”—em dash.</p>
                    <p>This para ‘contains’ – an en dash and <code>an</code>—em dash.</p>
                    <p>x, y, z, etc. – something else</p>

# Can we have comments after the end of the document?
# Yes we can!
