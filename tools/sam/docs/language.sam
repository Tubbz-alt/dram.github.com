specification: Semantic Authoring Markdown (SAM)

    introduction:

        note:
            This document is a formal description of the SAM language. It describes the formalisms behind the syntax and it may make SAM sound a lot more complex to work with than it really is. If you just want to learn how to write in SAM, see the {SAM Quick Start}(document).

        Semantic Authoring Markdown (SAM) is a simplified markup for semantic authoring. Semantic authoring means writing texts that identify some part of their semantics thought embedded markup. Semantic authoring also places constraints on the author, making sure they create the content that is required. Semantic authoring allows for sophisticated validation and manipulation of content, supporting increased quality and improving the efficiency of the publishing process.

        SAM is a tale that grew in the telling. It was designed from the bottom up, not the top down, and so formalizing the language description comes after the fact. This document is a step along the way to a fully formal definition. There is not yet a full formal grammar for SAM. It is possible that the development of such a grammar could reveal ambiguities in the language definition that might require design changes in the future. 
        
        section: Why SAM?
        
            Why is SAM needed? What are the limits of current semantic authoring solutions? The core of a semantic authoring solution is a markup language. There are, broadly, two kinds of markup languages: general and lightweight. Lightweight markup languages are easier to use, but less capable. XML is the only general languages in common use today (thought SGML is also still in use). There are many lightweight markup languages. The best known is Markdown.
            
            The key issue for real semantic authoring is extensibility: the ability to specify your own semantics. (To create new tag that are specific to what you are writing about.)
        
            Current lightweight markup languages have fixed semantics with little or no extensibility. Where extensibility exists, it generally requires coding extensions to the parser. 
            
            XML supports extensibility through schemas. But the price it pays for this is an abstract data model and a verbose syntax. Writing and editing in XML is cumbersome, even with a dedicated XML editor (and dedicated XML editors can be expensive). And while XML is intended for doing structured writing, in practice it tends to hide the structure of the content either behind a WYSIWYG editing interface or verbose markup.
            
            SAM attempts to bridge these two worlds, providing a lightweight syntax that is easy to read, write, and edit, and which makes the structure of the content clear and explicit. SAM is also designed to be extensible and to support the specification of new tags through a schema. (Currently the SAM Parser uses an XML schema language to validate the output XML, but a true SAM schema language is planned.)
            
            Most lightweight markup languages provide a fixed set of document structures with little or no extensibility. XML provides no document structures by default and makes you specify everything in a schema. SAM defines a limited set of core text structures such as paragraph and lists and then leaves it to you to specify the semantic structures that contain the text.

            It is important to note that SAM is not designed as a language for text representation. That is, it is not a language designed for taking an existing text, and, without violence to that text, adding metadata to explicate its meaning or structure. For that you need a form of markup with the ability to clearly delineate in-band and out-of-band data. XML provides this by consigning in-band data (the text of the document) to the textual content of elements, and out-of-band (metadata describing the document) to attributes. SAM defines a few preset management attributes but provided no facility for creating new ones. Any additional metadata you want to add to a block, for instance, has to take the form or fields. This muddies the distinction between in-band and out-of-band information. For content creation, this is entirely appropriate, and the whole element/attribute distinction is tedious and confusing. If you are looking for a markup language that is designed so that you can simply remove the markup and be left with the original document, SAM is not the right choice.

        section: Processing model
        
            SAM is a cross between an abstract or meta language like XML and a concrete language like MarkDown. XML does not describe the semantics of any of the tagging languages you base on it. The XML parser does not implement any markup semantics. Implementing semantics is left to the application layer -- another program or set of program that process the output of the parser. In many XML-based tool chains, the application layer is written in XSLT. Markdown describes the entire semantics of the language. The Markdown processor executes the entire semantics of the language, producing HTML output directly from Markdown. It does not require a separate application layer.
            
            SAM follows the XML model. The SAM parser simply reads the SAM markup and extracts its structures. It does not interpret the semantics of the document, but leaves that to the application layer.

            A SAM parser may make the structure of a SAM document available to the applications layer in different ways. It can expose the structure via an API and/or it may output an XML representation of the structure of the SAM document.
            
        section: Semantics

            While the SAM parser does not act on the semantics of the document, deferring that to the application layer, it contains concrete markup which the writer is entitled to expect will be processed in a particular way. These are the intended semantics of SAM structures. The application layer is expected to honor and implement the semantics of SAM markup.

            A lot of SAM's concrete markup is simply shortcuts for common writing structures like lists. The exact same structures could be created using blocks, fields, and paragraphs, and you can create variant structures (other types of lists, for example) using these standard components. However, some of SAM's concrete markup expresses a particular view about markup language design. For example, it use of annotations and citations expresses a particular view about how text inside paragraphs should be marked up. Since SAM does not provide other facilities to create markup in paragraphs, it may not be suitable for expressing all types of markup language design. SAM is not, and is not intended to be, a full replacement for XML.

        section: SAM Structure

            Like all other markup languages, a SAM document is essentially a set a set of nested blocks of various types. In concrete markup languages like markdown there are a fixed set of block types, each with a specific meaning, and each with a corresponding piece of syntax that allows the parser to identify them. In an abstract markup language like XML, there are a few abstract block types that have no inherent meaning, but can be named so that a processing application can attach meaning to the name in specific markup languages. Thus a paragraph is represented with a `<p>` element in HTML but by a `<para>` element in DocBook. 

            As a hybrid language, SAM has a set of concrete block types, each with its own semantics and syntax, and a set of abstract nameable block types that can be used to define additional semantics for specific SAM-based markup languages. Thus in SAM a {paragraph} is always created as a block of text, but you can create named blocks to capture things like `author-name:`.  

            Blocks may contain flows. A flow is a data value, the contents of a block, but a flow can also contain other structures. This is also a common feature of document markup languages. In HTML, for instance, you can have an `<a>` element in the middle of a paragraph to create a link. XML-based languages, including HTML, use elements for structures within a flow (creating something called mixed content). In SAM, structures within a flow are distinct from blocks and have a different syntax.

            Four kinds of structures can exist in a flow, a {phrase}, an {insert}, and a {citation}. However, a {phrase} can be annotated to indicate its semantics, which makes {phrase}s an extensible feature of SAM. 

            The following example shows a {paragraph} with two annotated {phrase}s.

            ```(sam) 
                In {Rio Bravo}(movie), {the Duke}(actor "John Wayne" (SAG)) plays a union colonel.



        section: SAM Syntax
            
            Syntactically, SAM takes its cues from YAML and Python (for displaying overall structure), from Markdown (for displaying text structures) and from common English usage (for displaying annotations.) In contrast to some of the richer lightweight markup languages, it tries to minimize the use of exotic forms of punctuation to delineate structures. 
            
            The intention is that an author writing in SAM should feel no need to use a visual editor, but should work directly in raw SAM (albeit with editor-supplied syntax coloring if desired). A SAM document should be a very natural read. 

            SAM is not designed to be a full replacement for XML. It is far less general, because of its use of predefined syntax for common text structures such as lists and paragraphs, and it has very limited support for attributes. Basically, each structure has a fixed set of attributes available. There is no extensibility for attributes. This is essential to maintain the readability of SAM sources, but it limits certain styles of markup design.
            
            In particular, SAM is designed to support a declarative approach to semantic authoring meaning that it is designed to express declarations about the structure of the document and the meaning of the text, rather than to embed management and processing information into the source, a practice common in many structured authoring languages. 

            Document-oriented markup languages such as reStructuredText and Markdown tend to be very flat in structure. One things follows another. There is rarely a case where one thing is inside another. For example, these languages use heading levels, but don't delineate sections of the document. More semantically rich languages tend to be more hierarchical, with one structure inside another. For example, a document might be divided into sections with title and paragraph elements inside a section. This means that you need to show which structures are inside others and where the containing structure ends. 

            XML does this by having an explicit end tag for every element. A large part of the verbosity of XML comes from its requirement to close every element tag. Many programming languages, which similarly have to express nested structures, use some form of brackets to delineate each structure. Python is an exception to this. It uses indentation to express the relationship between structures. This is a far more natural way for writers to express the subordination of elements -- one that is sometimes also used in published works. SAM uses this approach and avoids the use of end tags entirely.

            SAM syntax defines the following structures:

            |named block| Named blocks are structures that contain other structures. For instance, a section is a block. Blocks must have names. Named blocks (and named fields) are how you introduce new structures into a SAM document. Named blocks may be referred to a "blocks" in this document, but all of SAMs concrete block types are also blocks.

            |field| Fields are named blocks that contain individual values. For instance, the date a document  is usually a field.

            |flow| A flow is a string of text. All text content in a SAM document constitutes a flow. A {paragraph} is a flow. The {value} of a field is a flow. A {title} is a flow. Etc. Flows can contain {phrases}, {citations}, and {inserts}.

            |paragraph| A paragraph is a continuous block of text across one or more contiguous lines. The content of a paragraph is a {flow}.

            |phrase| A phrase is a string of characters in a flow. You use a phrase when you want to attach an annotation or a citation to a string of text.

            |string| Strings are named pieces of text that can be included by reference in other parts of a document or in other documents.

            |annotation| Annotations are metadata attached to a phrase.

            |attributes| Attributes are metadata attached to a block. There are a very limited set of attributes with specific rules for where they can appear. For most of the purposes for which you would use attributes in XML, you should use fields in SAM.

            |block insertion| Block insertions are an instruction to the application layer in content from an internal or external source at the block level.

            |flow insertion|  Flow insertions are an instruction to the application layer in content from an internal or external source at the flow level (that is, inside a flow).
            
            |citations| Citations are references to other works or structures.
            
            |embedded XML| You can embed XML in a SAM document. 
            
            |include| You can include one SAM file in another.

            |ordered list| An ordered list is as list in which the order of the items is meaningful. An ordered list is any sequence of one or more ordered list items.

            |unordered list| An unordered list is a list in which the order of the items is not meaningful (as least as far as markup semantics is concerned). A unordered list is any sequence of one or more unordered list items.

            |labeled list| A labeled list is a list in which each item has a label (rather than a bullet or a number). A labeled list is an sequence of one or more labeled list items. A labeled list item consists of a label and a single paragraph.

            |line| A line is a single line of text, as in a poem, with a fixed line end. The contents of a line is a {flow}.

            |record set| A record set is a simple database table with named columns. It allows you to capture tabular data at a semantic level rather than at the presentation level of a table.

            |grid| A grid is a simple table-like layout structure.

            |fragment| Fragments are sections of a documents (potentially larger than a single paragraph) that can be included by reference in other parts of a document or in other documents. Strings used in a fragment can be redefined when a fragment is reused, allowing you to vary the text of the fragment when it is used in different places. (Note that this is describes the {presumed semantics} of fragments. Implementation of these semantics is up to the application layer.

            |comment| A comment on the SAM markup file itself, as opposed to a comment on the document. For comments on the document, use remark

            |remark| A remark is a comment on the text of the document, intended for editorial purposes. It must be attributed to a specific author.

        section:(#nametoken) Name tokens

            Several things in SAM have names. These names must be valid name tokens. A name token in a SAM document must be a valid XML local name. This is to allow ease of integration with XML tools and languages and for a straightforwards serialization of SAM documents to XML.

        section:(#name-like-string) Name-like string

            A name like string is a string that looks like a name. Name-like strings are used in parsing SAM files to detect the intention of the author to create a name. Not all name-like-strings are valid names. If the parser sees a name-like-string that is not a valid name, it reports an error. 

            The reason for recognizing name-like-strings rather than only recognizing valid names is that it enables the parser to catch cases where the writer probably intended to create a name but failed to create a valid name.  

            By recognizing name-like-strings the parser is able to report an errors on these dubious cases, which reduce the likelihood or misinterpreting the author's intent. In the case where the name-like-string is indeed intended to be interpreted as plain text, the writer can ensure it is interpreted as such by escaping the concluding colon with a backslash. 

            However, the definition of a name-like-string can't interfere with the recognition of other SAM structures. Therefore name-like-strings don't include characters that might be mistaken for SAM markup. 

            The current definition of a name-like-string is as follows, but this is subject to change:

            ```(re)
                (?P<name>\w[^\s`]*?) 

        section:(#syntax) Syntax

            A {block} in SAM is formed by starting a line with a name followed by a colon:

            ```(sam)
                description:
                    This is the content of a block named "description".

            Structures in SAM can contain other structures. The hierarchy of structures in SAM is defined by indentation. In the example above, the paragraph structure is inside the block named description because it is indented under it. 

        section:(#SOM) SAM Object Model

            The SAM Object Model is a way of representing the structure of a SAM document as a data structure to a computer program. The SAM object model is a way for program to access a SAM document in a standard way. Unless you are concerned with writing programs to access the SAM Object Model you can ignore all references to it in this document. The SAM Object model is the model implemented by the current SAM parser, which is written in Python. However, SAM parsers are not required to implement the SAM Object Model. 

            The other way for applications to access the structure of is by serializing it to XML. This is the only require access method for parsers to implement.

            Like the language itself, the SOM is a tale that grew in the telling. In the absence of a full formal grammar for SAM, the object model must be considered provisional. It should be considered a less stable interface to a SAM document than the canonical XML serialization. 
        
        section:(#parser) Parsing

            A SAM document may be interpreted by a SAM parser to form an object tree in memory, which can include the {SAM object model} or any standardized XML representation such as SAX or DOM. In these cases, the DOM or SAX interface should represent the standard XML serialization, or an optional variant of that serialization, not the SOM. A SAM parser must offer the option of serializing the document as XML. A SAM parser may offer various methods of serializing XML, but it must default to the serialization described in this document. 

    structures:
        The following is a list of the structures of a SAM document.

        structure:(#root) Root
            Every SAM document has a root which contains the entire content of the document. The root can contain a single block which is the parent of all other blocks in the document. This block is called the {document block}.  

            syntax:
                The {root} had no syntax of its own. It is an implicit container for the contents of the file. 

            semantics:
                None. The root is just a container.

            model:
                The {root} can contain the following, in order:

                * One or more {declaratiom}s.
                * One of more {comment}s, {remark}s, or {string definition}s.
                * The {root} block.
                * One of more {comment}s, or {remark}s.

            serialization:

                None. Only the children of the root are serialized.

            SOM:
                The {root} is represented by a {Root}(SOM_object) object that is created automatically by the parser when parsing starts. 
            
                All {declarations}, {comments}, {remarks}, and {string definitions} prior to the document block, and the document block itself, are children of the {Root} object. 

                Note that the SOM {Root} object is not the same thing as the {document block}. The {Root} object is a container for all the structures declared at column zero in the SAM document. The {document block} is the only {block structure} permitted as a direct child of the {Root} object. 

        structure:(#document-block) Document block

            The {document block} is the first structure declared in the document after any {declaration}s, {comment}s, {remark}s or {string definition}s. It is the container for all other blocks in the document. 

            Any type of {block} can be the {docuemtn block}. However, choosing a structure other than a {named block} as the document block will be extremely limiting, as most {concrete block} types allow for little of no nesting of other blocks. For instance, nothing can be nested under a {paragraph} so while a paragraph can be the document block of a SAM document, it would also be the only structure in the document. 

            syntax:
                The {document block} is not indented. All other structures in the document (excluding {comments}, {declarations}, and {string definitions}) must be children of the {document block}, and therefore must be indented under it. In all other respects, the syntax of the document block is the syntax of it type. 

            semantics:

                The {document block} determines the type of the SAM document (just as the root element name in XML forms the type of an XML document). In all other respects, the semantics of the {document block} are no different from the semantics of that structure type. 

            serialization:

                The {document block} is serialized according to its block type. In addition, however, if a namespace is declared for the document, the appropriate namespace declaration will be added to the root element generated. 

            SOM:
                The document block is the only block child of the {Root} object. In every other respect, it is represented as its normal block type.

        structure:(#declaration) Declaration

            A SAM file may start with one or more declarations. A declarations gives the SAM parser information it needs to correctly parse the file. Declarations do not become part of the output.

            syntax:
                Declarations must come before all other content. A {declaration}(structure) is created by a line beginning with  an exclamation mark followed by an declaration type followed by a colon.

                ```(sam) 
                    !namespace: http://spfeopentoolkit.org/sam/ns/tests

            semantics:
                A declaration is an instruction to the parser on how to interpret the SAM document. Declarations are not part of the content of the document described by the SAM markup. Rather, they describe the markup itself.    

                Currently the only declaration supported is the namespace declaration which sets the namespace for the entire SAM document. You cannot assign namespaces to individual structures in the text of a SAM document like you can in XML.

            serialization:
                The namespace declaration causes the namespace of a document to be set to the specified namespace. This will result in the appropriate namespace declaration in the serialized XML file. A parser may handle namespace prefixes in any way it sees fit. 

            SOM:
                The namespace declaration is used to update the namespace property of all blocks. In future, the namespace property of blocks may be set by the schema. 

             future:
                The schema declaration specifies the location of a schema file. The location will be processed through an XML catalog if one is specified to the parser. If a schema is specified, the namespace declaration is ignored and namespaces are assigned per the schema. A schema may assign different elements to different namespaces.

                ```(sam) 
                    !schema: http://spfeopentoolkit.org/schemas/think-plan-do-topic.sams

        structure:(#block) Named Block

            A {named block} is an abstract structure which allows you to extend SAM to express many different document structures. The name of a {named block} must be a valid {SAM name}.

            syntax:

                A named block is indicated by the appropriate indent followed by a {name-like string}, followed by a colon:

                ```(sam)
                    movie-review:

                To be considered a block, rather than a {field}, a {block} must have children. Children can be any other block types:

                ```(sam)
                    movie-review:
                        movie: Rio Bravo
                        stars:
                            star: John Wayne

                The example above contains two blocks (`movie-review` and `stars`) and two {fields} (`movie`) and (`star`).

                A named block can have a value:

                ```(sam)
                    movie-review: Rio Bravo is Classic Western

                Here the string "Rio Bravo" is the value of the block. The value of a block is regarded as the title of document section formed by a block, and is serialized as such. 

                A named block can have {attributes}. 

                A block can also have a title:

                ```(sam) 
                    section:(?ultra)(#ultra) The ultra feature is really cool!
                
                If there is any value after the colon and the attributes, it is considered a title for the {block} and generates a title structure. There must be a space between the colon or the closing parenthesis and the value.

                Blocks have children. To be considered a {block}, a structure must have children. That is, it must have other structures indented underneath it. If it has no children, it is interpreted as a {field}.


            semantics:
                The title of a a {block} is treated as the title of a the entire content of a {block}, and will be serialized as such. 

                Structurally, the title of a {block} is its value, in just the same way that the content of a field is its value. 


            serialization:
            
                Thus the SAM markup above would create the following XML output:
                
                ```(xml)
                    <section conditions="ultra">
                        <title>The ultra feature is really cool!</title>
                        ...
                    </section>
                
            SOM:
                The representation of a block in the {SOM} is identical to the representation of a field. A block is distinguished from a field in the SOM by whether or not it has children. 

        structure:(#attribute) Attributes

            Attributes are metadata on a block.  

            syntax: 

                Attributes are contained in parentheses that follow the colon of a {block} header with no space:

                ```(sam) 
                    name:(?BC) Fred Flintstone

                A block can have multiple attributes, one after another, with no spaces between:

                ```(sam) 
                    name:(?BC)(#fred) Fred Flintstone 

                There are four general attributes. The type of an attribute it determined by the flag character that precedes it. The four general types are:

                * {Conditions}(feature), which start with a `?`
                * {Name}(feature), which start with `#`
                * {ID}(feature), which start with `*`
                * {Language}(feature), which start with `!`

                Condition expressions must not include commas. 

                Names must be SAM {name tokens}.

                IDs must be SAM {name tokens}.

                Languages should be {BCP 47} language codes, but the parser is not required to enforce this. 

                Certain block types take additional attributes with meanings specific to those block types. 


            semantics: 

                Attributes provide support for basic {management domain} metadata in a SAM file.

                Unlike XML, SAM does not support arbitrarily named attributes. Only a fixed set of management attributes are supported. The semantics of each attribute type is as follows:

                |Condition| A {condition} attribute is used to determine if a block should appear in a particular output or not. If the condition expression evaluates to true, then the block is included. If it evaluates to false, it is not included. 

                            Conditions are evaluated from the outside in, so if a block is conditional excluded, all its contents are excluded, regardless of any conditional expressions that may occur on any of its children. 

                            The syntax, interpretation, and truth values of condition expressions are left entirely to the application layer. Similarly, including or excluding blocks is left entirely to the application layer. 

                            Multiple conditions may be applied to the same block. 

                |ID| An {id} attribute assigns an ID to a block. That id can be referenced by an {idref}. IDs must be unique in a file. IDRefs must refer to an ID in the current file. The action to be taken by the application layer on encountering an IDref is up to the tagging language designer. 

                     Multiple ids are not permitted on the same block. 

                |Name| A {name} attribute assigns a name to a block. A name performs the same function as an ID, allowing the block to be references from elsewhere. However, there are no limits on the scope of names. Uniqueness of names is not enforced. Name references are not required to match a name in the current file. This allows you to use names to reference blocks in other files. (Note the namerefs so not support naming the file in which a name is located. Rather it is left to the application layer to locate names by whatever mechanism seems appropriate.)  

                |Language| A {language} attribute specified the language in which the content of a block is written. It is expected, but not required, that standard {BCP 47} language codes be used to identify languages. 

                Certain block types have additional attributes that are specific to those block types. See the relevant entries for details. 

                This is the list of the standard attributes allowed on each structure. Block types that take special attributes are indicated with an asterisk:

                +++
                    block             | !language | #name | ?condition| *id | 
                    field             | !language | #name | ?condition| *id | 
                    fragment          | !language | #name | ?condition| *id | 
                    grid              | !language | #name | ?condition| *id | 
                    recordset         | !language | #name | ?condition| *id | 
                    ordered-list-item | !language | #name | ?condition| *id | 
                    unorderd-list-item| !language | #name | ?condition| *id | 
                    line              | !language | #name | ?condition| *id | 

                    blockquote        | !language | #name | ?condition| *id | 
                    phrase            | !language | #name | ?condition| *id | 

                    codeblock         |           | #name | ?condition| *id | *

                    string-def        |           |       |           |     | 

                    paragraph         |           |       |           |     | 
                    record            |           |       |           |     | 
                    XML               |           |       |           |     | 

                    block insert      |           | #name | ?condition| *id | *
                    inline insert     |           | #name | ?condition| *id | *
                    include           |           |       |           |     | *

                note:
                    It should be noted that the lack of arbitrary named attributes does not reduce the semantic flexibility of SAM as compared to XML. Any metadata that can be expressed by an attribute on a block can also be expressed by a field that is a child of that block. The reason for using attributes in XML is to preserve a pure distinction between text and metadata, but that is not a design consideration in SAM, which is meant for the creation of new text through structured writing, not for the annotation of existing texts for study.

            serialization:
                Attributes are represented in XML by XML attributes on the block element. 

                * {language} is represented by and `xml:lang` attribute. 
                * {ID} is represented by an `id` attribute.
                * {name} is represented by a `name` attribute.
                * {condition}s are represented by a `conditions` attribute. If multiple condition attributes are applied in SAM, they will be concatenated with commas in the `conditions` attribute value. 

            SOM:
                Attributes are represented by the attribute field of the {Block} object as a dictionary. 
        
        structure:(#field) Field
        
            A field is named structure with a single value. Fields take the same attributes as {block}s.  

            syntax:
            
                A field is syntactically identical to a {block}. It is simply a block with no children:

                ```(sam)
                    name: Fred Flintstone
                    address: Bedrock
                    era: BC

            semantics:

                A {field} is essentially a way of creating a key-value pair in a document. 

            serialization:
                    
                A field is serialized as an XML element. The field content is the data content of the XML element. The name of the XML element matches the name of the field. Thus the example above would be serialized as:
                
                ```(xml)
                    <name>Fred Flintstone</name>
                    <address>Bedrock</address>
                    <era>BC</era>

            SOM:
                A {field} is represented by a {Block} object. The only difference between a {block} and a {field} is whether it has children. If it has children, it is a {block}. If not, it is a {field}. 

                This design is mostly to make parsing easier. When we see a {field} definition in a file we can't tell without looking ahead whether it is going to have children or not. Therefore we treat it as a {block}. The difference between a {field} and a {block} really only occurs on serialization, where the content of a {field} is simply its text value, whereas the content of a {block} is treated as a title and output as a `<title>` element. 

                Programs accessing the {SOM} directly should note that the value of a {block} should be treated as the title of that {block}.

                The value of a {field} is contained in a {Flow} object.

        structure:(#flow) Flow

            A {flow} is a section of document text in a SAM document. A {flow} can contain intra-textual structures like {annotation}s, {decorations}, and {inline insert}s.  

            syntax: 
                There is no special syntax to define a {flow}. Flows are defined by their relationship to other structures.  All flows are trimmed of leading and trailing whitespace. In composing a flow from multiple text lines, all spaces and returns are collapsed to a single space.

            semantics:
                The text in a {flow} is simply text, along with any intra-textual structures it contains. 

            serialization:
                The flow object is not represented as an object in XML. Its content becomes the content of whatever element is created to represent the structure that contains the flow.

            SOM: 
                A {flow} is contained in a {Flow} object.

        structure:(#paragraph) Paragraph 

            A paragraph is a block of text. (SAM) has no opinion on whether the block of text would be considered a paragraph in grammatical or literary terms. As far as SAM is concerned, it is simply a block of text set off from other blocks of text and other structures. (This is identical to the meaning of paragraph in most markup languages.)

            The entire content of a paragraph is a single {flow}.

            syntax:

                A paragraph is indicated as sequence of lines ending with a blank line.

                ```(sam)
                    Now is the time
                    for all good men
                    to come to the aid
                    of the party.
                    
                    It was the best of 
                    times, it was the 
                    worst of times.

                Any line that in the source that is not identified as a different structure, or an attempt to create a different structure, is identified as a paragraph. 

                In some cases a paragraph may begin with a sequence that looks like an attempt to create a different structure. For instance, if there is a colon before the first space in a paragraph, and if the string before the colon is a name-like-value, then the writer can prevent the sequence being recognized as a {block} or {field} by escaping the colon with a backslash or a {character escape}.

                Once the first line of a paragraph has been identified, the parser simply accumulates subsequent lines, without looking for other structures, until one of the following is encountered:

                * A blank line.
                * A line whose indent is less than the indent of the first line of the paragraph.
                * If the paragraph is the child of a list item, the start of a new list item.

                A paragraph cannot have block children. Is is an error is any structure is indented under a paragraph. 

                note: 
                    Some writers may instinctively indent a list under the paragraph it follows. This is an error in SAM. A list is always the peer of the preceding paragraph is SAM and as such the list items must start at the same indent level as the preceding paragraph. The output formatter may, of course, choose to indent lists relative to their sibling paragraphs.  


            semantics:
                A paragraph is block of text.

            serialization:
                    
                A paragraph is serialized as a XML `p` element. Thus the example above would be serialized as the following XML:
                
                ```(xml)
                    <p>Now is the time for all good men to come to the aid of the party.</p>
                    
                    <p>It was the best of times, it was the worst of times.</p>

                A paragraph cannot have block children. It is a syntax error to have anything indented under a paragraph.  

            SOM: 
                A paragraph is represented by a {Paragraph} object with a single child {Flow} object.
                
        structure:(#phrase) Phrase

            A phrase structure is a delineated string of text within a {flow}. You create a phrase in order to add an {annotation} or {citation} to a word or phrase in the text. 

            syntax:
                A phrase is indicated by surrounding the phrase with curly braces:

                ```(sam) 
                    In {Rio Bravo}, {the Duke} plays a union colonel.

                It is not an error to have a phrase with no {annotation}s or {citation}s attached. When such as phrase is found, the parser must:

                * First, look backward through the document to find out if the same phrase has been annotated before. If it finds the same phrase, with an annotation, it copies the entire phrase and all attached {annotation}s and {citation}s to the current phrase. The search proceeds in reverse document order and stops at the first instance found. 

                * Second, if no matching phrase is found, the parser must issue a warning for the unannotated phrase.

                The search is conducted on a strict literal string basis, and is case sensitive.  

            semantics:
                A phrase has no semantics of its own. Its semantics are determined by any {annotation}s attached to it. 

            serialization:
                A phrase is serialized as a `phrase` element in XML.

                ```(xml) 
                    <p>In <phrase>Rio Bravo</phrase>, <phrase>the Duke</phrase> plays a union colonel.</p>

            SOM:
                A phrase is represented by a {Phrase} object.

        structure:(#annotation) Annotation

            Annotations clarify what a piece of text is about.  

            syntax:
                An {annotation} is attached to a phrase and is expressed as an expression in parentheses following the closing `}` of the phrase with no space in between. 

                An {annotation} consists either of one of four management attribute types (language, id, name, condition) or an {annotation} type expression. 

                An attribute annotation looks like this:

                ```(sam)
                    In Quebec, a stop sign says {arrêt}(!fr).


                An annotation type expression is an expression that specifies the type of a string. Here the type expression says that the string "Rio Bravo" is a reference to a movie: 

                ```(sam) 
                    In {Rio Bravo}(movie), {the Duke}(actor "John Wayne" (SAG)) plays a union colonel.


                There are three parts to an annotation type expression: 

                |type| The first word immediately following the opening parentheses is the type of the subject being annotated. In the sample above, "Rio Bravo" is a movie and "the Duke" is an actor. An annotation type must be a valid SAM {name}. The annotation type is required.

                |specifically| In some cases, the annotated text may not specify its subject clearly. In this case, the specifically attribute is use to clarify what is meant. The specifically attribute is a string in double or single straight quotes. In the sample above, "the Duke" means, specifically, "John Wayne". The specifically attribute is optional.

                |namespace| In some cases, it is necessary to specify the namespace to which the annotated term belongs. The namespace attribute follows the specifically attribute (if specified) and is contained in parentheses. In the sample above, the name of the actor "John Wayne" is part of a set of names managed by the Screen Actors Guild which makes sure two actors don't use the same stage name. (In most cases, the namespace is implied by the type, so you will not usually need to specify it.) The namespace attribute is optional.

                If you are annotating the same phrase more than one in the same file. You can skip the annotation metadata and just use curly braces around the phrase. The parser will copy the metadata from the last occurring instance of that same phrase.


            semantics:
                The specific semantics of individual annotation depend on the language designer, however, in order to maintain consistency across languages, it is important to use the specifically and namespace attributes for their intended purposes and not to hijack them to express some other semantics. 

                Type annotations may be from any of the structured writing domains (media, document, subject, management). The relationship between the annotation type and the meaning of the specifically attribute changes in each domain. 

                In the media domain, the annotation type refers to some media property to be applied to the text, and the specifically attribute supplies more specific information. For example it could be `{the Duke}(highlight "yellow")` or `{the Duke}(link "http://JohnWayne.com")`.

                In the document domain, the annotation type refer to some document property, and the specifically attribute supplies more specific information. For example, it could be `{the Duke}(index "Wayne, John")`.

                In the subject domain, the annotation type refers to the type of the subject being referred to and the specifically attribute clarifies the intended subject if required. For example `{the Duke}(actor "John Wayne").

                The key to using the annotation attributes correctly is simply to make sure that the attribute names apply in a reasonable fashion to the values they contain. If they don't, a different markup strategy should be used. 

                The semantics of management attribute annotations are as follows:

                * {condition}(attribute) determines if the {phrase} will be included in the output or not.
                * {Name}(attribute), assigns a {name} to the {phrase} so it can be referred to elsewhere.
                * {id}(attribute), assigns an {ID} to the {phrase} so it can be referred to elsewhere.
                * {language}(attribute), specifies the language in which the phrase is written. 

            serialization:

                An annotation is serialized as an `<annotation>` element. The type, specifically, and namespace attributes become attributes with those names in XML. 

                The `<annotation>` element is wrapped inside the `<phrase>` element that it annotation, with the content of the phrase on the inside.

                ```(xml) 
                    <p>In <phrase><annotation type="movie">Rio Bravo</annotation></phrase>, <phrase><annotation type="actor" specifically="John Wayne" namespace="SAG>the Duke</annotation></phrase> plays a union colonel.

                When a phrase has one or more annotations, those annotations are wrapped inside the `<phrase>` element in the order in which they occur in the source document. Thus the following:

                ```(sam)
                    The film starred {John Wayne}(actor)(director), who also directed.

                would be serialized as:

                ```(xml)
                    <p>The film starred <phrase><annotation type="actor"><annotation type="director">John Wayne</annotation></annotation></phrase>, who also directed.

            SOM:
                An annotation is represented in the {SOM} by an Annotation object. 

        structure:(#citation) Citation 

            Citations are a reference to another resource. This includes internal references to other structures within the document, such as to a graphic,procedure, or footnote, as well as references to external works. Citations are supported wherever {attributes} or {annotations} are supported.

            syntax:

                A citation is created using square brackets:

                ```(sam) 
                    Moby Dick[Melville, 1851] is about a big fish.

                They can also be applied to a phrase, rather then floating in the text. 

                ```(sam) 
                    {Moby Dick}[Melville, 1851] is about a big fish.

                Citations can be chained with annotations:

                ```(sam) 
                    {Moby Dick}(novel)[Melville, 1851] is about a big fish.

                Citations can also be added to {blocks}. The most obvious application of this is {blockquote}s:

                ```(sam)
                    """[Melville, 1851] 
                        Call me Ishmael.

                SAM has no opinion about the format of a citation text. That is entirely up to the application layer to decipher. 

                You can also use citations to reference other parts of the current document or other documents. To cite a resource that has an id within the current SAM document, reference the id like this: 

                ```(sam) 
                    Moby Dick is about a big fish[*moby]. See [*whale].

                    fig:(*whale)
                        >>>(image whale.png)

                    footnote:(*moby)
                        Actually, Moby Dick is a whale, not a fish.

                Citation by {idref}, {nameref}, or {keyref} can include additional information. For example, if you have a bibliography where each bibliography entry has a name assigned to it, you could cite the work by reference to the name, and then add additional information for the page number.

                ```(sam)
                    """[#Moby page 1] 
                        Call me Ishmael.

                The additional information is anything between the end of the {nameref} and the closing square bracket.

            
            semantics:

                The function of a citation is to generate a piece of content in the output that is a reference to the specified resource. Some text should always be generated in the place where the citation is specified. What type of reference that is depends of the type of object that is being referenced. Generating such references is the job of the {application layer}.

                The purpose of a citation is not to create a link. Links should be created using {annotation}s. However, the reference generated by a citation may include a link to the resource in question if appropriate. 

                The semantics of a reference by {idref}, {nameref}, or {keyref}, depend on the type of the structure referred to. Thus if the type of a object referred to by an {idref}. This will usually be a reference to a type that is created in the specific tagging language being used, rather than to a SAM concrete block, so the semantics are up to the language designer. For example, if your tagging language includes footnotes, as in the last example above then the presumptive semantics of a {citation} of the footnote ID would be to product a footnote marker in the output. 

                The semantics of a citation of an external work is that it will generate a reference to that work in whatever citation format is appropriate for publication. This means that a citation that is inline in the SAM document necessarily implies that an inline citation format will be used on output. The SAM citation is just capturing the citation information. It is up to the application layer to decide how to present it, including removing the citation to a footnote or endnote if appropriate. The language designer is entitled to specify any citation format they like, and to interpret it in any way they like. 

                Additional information in a citation is simply passed through to the application layer. SAM does not specify any semantics for it. 

            serialization:

                A {citation} is output as a `<citation>` element in XML. 

                The type of the citation is indicated by a `type` attribute. The supported types are:

                |citation| A textual citation. 
                |id| A SAM ID.
                |name| A SAM name.
                |key| A SAM key.

                The value of the citation is indicated by the `value` attribute.

                For example, 

                ```(xml) 
                    <p>Moby Dick<citation type="citation" value="Melville, 1851"> is about a big fish.

                If the citation is attached to a phrase, then the citation will be wrapped around the text of the phrase and nested inside the `<phrase>` element:

                ```(xml) 
                    <p><phrase><citation type="citation" value="Melville, 1851"/>Moby Dick</phrase> is about a big fish.

                If a citation and an annotation are attached to the same phrase, then the citation will be nested within the `<phrase>` element and relative to any `<annotation>` elements, just as with {annotation} nesting.

                ```(xml) 
                    <phrase><annotation type="novel"><citation type="citation" value="Melville, 1851">Moby Dick</citation></annotation></phrase> is about a big fish.


                If the citation is attached to a {blockquote}, the citation element will be nested inside the `<blockquote>` element.

                ```(sam)
                    <blockquote>
                        <citation type="citation" value="Melville, 1851"/> 
                        <p>Call me Ishmael.</p>
                    </blockquote>

                If a citation contains additional information, it is included as an `extra` attribute. 

                ```(sam)
                    <blockquote>
                        <citation type="nameref" value="Moby" extra="page 1"/> 
                        <p>Call me Ishmael.</p>
                    </blockquote>

                note:
                    Unlike other blocks, the serialization of a {citation} does not include a line feed after the citation tag. This is because a citation can also occur inside a flow, where the addition of a line feed would introduce extra whitespace into the flow. The lack of a linefeed in a block context does not change the semantics of the resulting document, but can make a difference in tests that compare literal XML output to expected output. 

            SOM:
                A {citation} is represented in the SOM by a {Citation}(object) object.

                When applied to a {block}, the {Citation} object is added as the first child of the block. 

                When applied to a {phrase}, the {Citation} object is chained in sequence with any other citations or annotations. 

                When a {citation} occurs standalone in a flow, the {Citation} object becomes an item in the {Flow} object list. 

            future:
                If the proposal to allow the definition of patterns in the schema is accepted, it may be possible to define the format of a citation text and to have the parser break it down into its constituent parts. 

        structure:(#insert) Insert

            An insert is an instruction to the {application layer} to insert a resource into the document output.

            Inserts may be created at the {block} level or inside a {flow}. 

            syntax:

                At the block level, an insert is placed
                on a line by itself and is indicated by three greater-than signs:

                ```(sam)
                    >>>(image foo.png)

                Inside a {flow}, an insert is indicated by a single greater-than followed the the identification of the
                resource in parentheses:

                ```(sam)
                    My favorite flavor of ice cream is >($favorite-flavor).


                The resource to be inserted may be identified either by type and URL as in the block example above or by
                reference to an {id}, {name}, {fragment}, {string}, or {key} as in the flow example.


                You can also assign {name}s, {condition}s, or {id}s to an insert. For example, to insert a fragment containing
                the introduction to the deluxe version of a product, you could do this:

                ```(sam)
                    >>>(~deluxe-intro)(?model=deluxe)

                Remember that it is up to the application layer to implement such inserts.

                You can use any name you like for the insert type, however the following types are reserved so that editors can act on them to provide enhanced views of the document while editing:

                * image
                * video
                * audio
                * feed
                * app

                They should be used only with their natural semantics.


            semantics:

                The insert is an instruction to the application layer to insert the specified resource. While implementation is entirely up to the applications layer, SAM specifies the semantics of the reserved insert types as follows:

                |"image"| Insert the graphic image into the output.
                |"video"| Insert the video into the output.
                |"audio"| Insert a playable audio clip into the output.
                |"feed"| Insert the result of a feed into the output.
                |"app"| Insert an embedded app into the output. 

                The semantics of inserting by reference to an {ID}, {name}, {fragment}, or {string}, or {key} are as follows:

                |a SAM {ID}| Insert the resource pointed to by the {ID} in a manner appropriate to its type.
                |a SAM {name}| Insert the resource pointed to by the {name} in a manner appropriate to its type. 
                |a SAM {fragment}| Insert the content of the {fragment} into this location in the document, and process any structures it contains. 
                |a SAM {string}| Insert the value of the string variable into the document, and process any structures it contains.
                |a SAM {key}| Insert the resource pointed to by the {key} in a manner appropriate to its type.

                Note that you are not obliged to use any of these types in order to do their assigned functions. You can devise any insert types you like, since responsibility for implementing them rests entirely with the application layer. The constraint is that you should not assign other semantics to these names. Having a standard set simply allows for editors to presume the semantics of the basic types and act on them if they wish.

            future: 
                It is currently possible to nest any structure as a child of an insert. This is to support the redefinition of {strings} in when inserting {fragments}. There does not seem to be any other use case for this, so it should probably be constrained at some level. Issue {120}(issue) tracks this.

        structure:(#include) Include

            You can include one SAM file in another. The included file must be a complete SAM file. Its structure is included in the structure of the included file at the indent level of the include statement. That is to say, the structures of the included file are treated as if they had their own indent plus the indent of the include statement.

            syntax:

                An include is indicated by the appropriate indent, followed by three less-than signs, followed by the path to a SAM file in parentheses.

                ```(sam)
                    <<<(foo.sam)

            semantics:

                Unlike inserts, which are simply passed on to the application layer for processing, the file pointed to by an {include} is parsed by the parser. The result of the include is presented to the application layer as part of the parsed document.

                The ID uniqueness constraint that applies to individual SAM document also applies to included files. The IDs must be unique across the entire document parsed from the source file and any included files.

                Includes cannot be made conditional, since conditions are parsed by the application layer and includes are processed by the parser. 

                If you need to apply a condition to an include, place the include in a fragment and make the fragment conditional. This will result in the file being parsed and included in the output, but its content will be inside the fragment, making the whole thing conditional. 

                For similar reasons, an include cannot have a {name}, {id}, or {language} attribute, since the include instruction itself is not present in the output. If you need to apply any of these things to the included content, you can wrap the include statement in another structure such as a {block} or a {fragment} and apply the attributes to that. This will
                result in the included content being wrapped in that block or fragment in the output where the application layer can deal with it appropriately.

            serialization:
                Include instructions are not serialized on output. Their content resulting from processing the include is serialized as it would have been if it were entered inline. 

            SOM:
                The {include} is represented in the {SOM} by an {Include} object. Thus it is possible when accessing the {SOM} to tell whether or not the content was part of an included file. It is not possible to tell this in the serialized XML output.

            future: 
                There is a proposal to decorate the IDs occurring in an included file to ensure they do not overlap those of the including file. See issue {104}(issue). 

        structure:(#string) String

            A string is a way of defining a variable to represent a value. 

            syntax:

                A string definition is created by the appropriate indent followed by a `$` and a {name-like-string} followed by an `=` and the value of the string. The string value ends at the end of the current line:

                ```(sam)
                    $foo = bar

                The string can then be inserted using a {block insert} or {inline insert}:

                ```(sam)
                    The sentence includes and string insert >($foo).

                    >>>($foo)



                String definitions do not take any attributes. The string name is a {name token}. String ids are not supported. If
                you want to make string definitions conditional, use fragments.

                ```(sam)
                    ~~~(?foo)
                        $foo = bar

                But remember that the resolution of string is left to the {application layer} so if you do this make sure your {application layer} code handles it correctly.

            semantics:
            
                String handling occurs in the {application layer}.

                The semantics of string definitions are: 

                * Within a local file, strings are local to the scope in which they are defined.
                * Within a local file, a later definition of a string overrides an earlier definition.
                * Strings defined in a {fragment} insert override the strings defined in the {fragment}.
                * Within a local file, a local definition of string overrides a more global definition of a string.

                The application layer is entitled to introduce string definitions from outside the local file and to impose its own rules on precedence for such strings.

        structure:(#fragment) Fragment 

            A fragment is a chunk of content that is set off so that it can be managed separately from the rest of the document. Reasons for creating a fragment could include making a chunk of the document conditional or available for reuse. 

            syntax:            

                Fragments are created by a token followed by an open curly brace at the start of a line: 

                ```(sam)

                    This paragraph is outside the fragment.

                    ~~~(?foo)

                        This paragraph is inside the fragment and should only appear if the {condition} `foo` is true.

                    This paragraph is outside the fragment again and will always be included.

                You can define a string inside a fragment and use that string in the definition of the fragment text:

                ```(sam) 
                    ~~~(#my-fragment) 
                        $color=black 
                        Bar bar >>($color) sheep Have you any wool? 

                To insert a fragment: 

                ```(sam) 
                    >>>(~my-fragment)
                
                Any strings defined within a fragment are scoped to that fragment (per normal {string} scoping rules. You can override these strings when you insert the fragment. In fact, you can override any in-scope strings in a fragment insert. String definitions must each be on a line by themselves. 

                ```(sam)
                    >>>(~my-fragment)
                        $color=white

            semantics:

                The handling of fragments and strings belongs to the {application layer}.

                Semantically, a fragment is just an arbitrary chunk of the document hierarchy. If it is inserted somewhere using an {insert} with a {idref}, {nameref}, or {keyref}, then the fragment is to be inserted at that location. 

                If a fragment is reuse in this way, and if there are {stringref}s in the body of the fragment, any strings defined in the fragment {insert} override those defined in the fragment and any other string definitions of the same name. 

                Fragments can be nested inside other fragments. Fragments can contain {inserts} of other fragments. Circular fragment references are illegal but must be caught at the application layer. 

            serialization:

                A fragment is serialized to XML as follows:

                ```(xml)
                    <fragment conditions="gruz-natz" name="foo3">
                    <string name="a">apple</string>
                    <string name="b">banana</string>
                    <p>This is a sentence inside a fragment.</p>
                    </fragment>

                A fragment insert is serialized like this:

                ```(xml)
                    <insert item="foobar" type="fragment">
                    <string name="a">apricot</string>
                    <string name="b">breadfruit</string>
                    </insert>

            SOM:
                A {fragment} is represented in the {SOM} by a {Fragment} object.

        structure:(#codeblock) Codeblock

            A codeblock is a block of computer code or data, or any other material with its own syntax that is to be presented as part of the document content. The contents of a codeblock are not interpreted by the SAM parser but are presented as entered in the source. 

            syntax:

                Codeblocks begin with three back ticks followed by optional {attribute}s.

                ```(sam)
                    ```(python)
                        print("Hello World.")

                Code must be indented under the codeblock marker. The codeblock ends at the first line that is less indented than the codeblock marker, or at the end of the file.   

                Codeblocks take the standard {attribute} types.

                Because is is delineated by indentation, the contents of a codeblock do not require any character escaping, and no SAM character escapes are recognized in a codeblock. The text is taken literally without modification of any kind. 

                Thus, for instance, you can show blocks of SAM in a SAM codeblock (as this document does) without any need for escaping any part of the markup. 


            semantics:

                The text of the codeblock is not processed as SAM markup. It is recorded as is with no interpretation or escape processing. Line breaks are preserved as in the original.

                Because indentation may be significant in a codeblock, and because the code will be indented under the codeblock header in the SAM source, the SAM parser uses the following algorithm to distinguish SAM indenting from indenting in the code itself: The parser looks at all the lines that are indented under the codeblock header, finds the one with the smallest indent, and treats it as occurring at the first column in the code. This allows for cases where the first line of a code sample may not be the least indented line. (That is, the first line of the code sample may be more indented than some of the lines that follow.) It also means that all codeblocks will be formatted with zero initial indent. 

                The semantics of the language attribute are slightly different for codeblocks, or at least, the implication of the semantics is. For other blocks, the language attribute denotes the human language of the text. For a codeblock, it denotes the computer or data language of the codeblock. In the unlikely event that you need to apply both languages, you should use a wrapper around the codeblock to capture the human language. For example, you might do this:

                ```(sam)
                    code-sample:(fr)
                        ```(sam)
                            La Plume de ma Tante.

            serialization:

                A codeblock is serialized like this:

                ```(xml)
                    <codeblock conditions="a,b" id="id12" language="python" name="name">
                    def escape_for_xml(s):
                        t = dict(zip([ord('&lt;'), ord('&gt;'), ord('&amp;')], ['&amp;lt;', '&amp;gt;', '&amp;amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s
                    </codeblock>

                Note that nothing is done to indicate that the contents of the codeblock are to be treated as preformatted. That is up to the {application layer}.

            SOM:
                A codeblock in represented in the SOM with a {Codeblock}(object) object. The contents of the codeblock are represented as an {Pre}(object) object. 

        structure:(#embed) Embedded markup
            You can embed markup in other markup languages. Unlike a codeblock, the intended semantics of an embed are that the markup will be processed in the application layer. For example, a piece of latex math markup might be processed in the application layer to display an equation.


            syntax:

                An embed works just like a {codeblock}, except that there is an {encoding} attribute on the block.

                ```(sam)
                    ```(=latexmathml)(*id13)(#name)(?a)(?b)
                        n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            semantics:
                Embedded markup is intended to be processed by the application layer and the results of that processing to be displayed. 

                Note that SAM knows nothing about the embedded markup and does not processes it in any way. It merely captures it and sends it on to the application layer.

            serialization:
                An {embed} is serialized as follows:

                ```(xml)
                    <embed conditions="a,b" id="id13" encoding="latexmathml" name="name">
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k
                    </embed>

            SOM:
                An embed is represented in the SOM as an {Codebloack}(object) object with an {encoding}(attribute) attribute. The contents are represented as a {Pre} object.

        structure:(#blockquote) Blockquote 

            A block quote is a quotation presented as a separate block rather than inline in a paragraph.

            syntax:
                A blockquote is created by and appropriate indent followed by three `"` or `'` characters followed by optional {attributes} and/or a {citation}.

                """[Mother Goose]
                    The quick brown fox jumps over the lazy dog.

                The contents of a blockquote is regular SAM markup, and thus can contain {phrases} and {annotations}.


            semantics:
                A blockquote is just like any other block with the exception that it is allowed to have a citation. The material inside a blockquote is treated as regular SAM markup and is processed as such.

            serialization:
                A blockquote is serialized as follows:

                ```(xml)
                    <blockquote conditions="foo">
                    <citation type="citation" value="Mother Goose"/><p>The quick brown fox jumps over the lazy dog.</p>
                    </blockquote>

            SOM:
                A blockquote is represented in the {SOM} by a {Blockquote}(object) object. The content of a blockquote are regular SAM objects which are children of the {Blockquote} object as normal for the children of any object. 

        structure:(#line) Line 
        
            A line is piece of text with fixed line endings, such as a poem. Lines are generally used in groups for a piece of text with fixed line endings. 

            syntax:
                To create a set of lines, precede each one with a pipe character followed by a space. 

                ```(sam) 
                    | You gotta walk that lonesome valley,
                    | You gotta walk it by yourself,
                    | Nobody here can walk it for you,
                    | You gotta walk it by yourself.


                You can also add {id}s or {condition}s to lines. In this case, the opening parentheses of the annotation must follow the leading pipe character immediately, and the closing parenthesis must be followed by a space: 

                ```(sam)
                    |(#foo2) You gotta walk that lonesome valley,[*bing page 22]
                    | You gotta walk it by yourself,
                    |(?bar) Nobody here can walk it for you,
                    |    You gotta walk it by yourself.

                The entire line must be on one line in the source.

                All spaces after the first space following the pipe are considered significant and are retained on output.

                A line cannot have children. 

                The text of a line is a normal SAM flow and is processed as such. 

            semantics:
                A line is a line of text with a fixed line break. Unlike a {codeblock}, the contents of a line are a regular SAM {flow}. 

            serialization:
                A line is serialized as follows.

                ```(xml)
                    <line name="foo2">You gotta walk that lonesome valley,<citation type="idref" value="bing" extra="page 22"/></line>
                    <line>You gotta walk it by yourself,</line>
                    <line conditions="bar">Nobody here can walk it for you,</line>
                    <line>   You gotta walk it by yourself.</line>

            SOM:
                A line is represented in the {SOM} as a {Line}(object) object.

        structure:(#unordered-list) Unordered List 

            An unordered list a piece of shorthand for a fully explicit unordered list structure. 

            syntax: 

                An unordered list item is created by starting a paragraph with a `*` followed by a space. Note that the space is require. Without it, the `*` will be recognized as the beginning of a bold {decoration}, or as plain text. 

                ```(sam)
                    * Dog
                    * Cat
                    * Monkey

                The text following the `*` is treated as a {paragraph}. This means that the ordered list above is equivalent to this:

                ```(sam)
                    ul:
                        li:
                            Dog
                        li: 
                            Cat
                        li:
                            Monkey

                and not this:

                ```(SAM) 
                    ul: 
                        li: Dog 
                        li: Cat 
                        li: Monkey

                The only way to get the latter structure is to enter it as shown above. 

                You can have more than one paragraph in a list item. To add a second paragraph, insert a space followed by a paragraph that is indented to the same level as the first letter following the `*` of the list item:

                ```(sam)
                    * How much is that doggy in the window.

                      I hope that that fleabag's for sale. 

                    * Hey diddle diddle, the cat and the fiddle

                      The cow jumped over the moon. 

                List can be nested. A nested list means that one list is the child of a list item in the parent list. To create this, indent the second list under an item of the first.

                ```(sam)
                    * Dogs
                        * Spot
                        * Fang
                    * Cats
                        * Mittens
                        * Skimbleshanks

                Note that when an unordered list follows a paragraph, it must be a the same indent level as the preceding paragraph, not indented under it. 

            semantics:
                Unordered lists using this explicit concrete syntax are more limited than the lists you could create with explicit {blocks} and fields. The only children a list item can have with this syntax are {paragraphs} and nested {unordered list}s or {ordered list}s.  

                Note that when an {unordered list} follows a {paragraph}, it is a sibling of that {paragraph}. A list cannot be the child of a {paragraph} since a paragraphs cannot have children. 

            serialization:
                An ordered list is serialized as follows. Note that the content of a list item is always wrapped in a `<p>` tag. 

                ```(sam)
                    <ul>
                        <li>
                            <p>Dogs</p>
                            <ul>
                                <li>
                                    <p>Spot</p>
                                </li>
                                <li>
                                    <p>Fang</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Cats</p>
                            <ul>
                                <li>
                                    <p>Mittens</p>
                                </li>
                                <li>
                                    <p>Skimbleshanks</p>
                                </li>
                            </ul>
                        </li>
                    </ul>

            SOM:
                An {unordered list} is represented by an {UnorderedList}(object) object. Each list item is represented by a {UnorderedListItem}(object) object. 

        structure:(#ordered-list) Ordered list

            An {ordered list} a piece of shorthand for a fully explicit ordered list structure. 

            syntax:
                The syntax of an ordered list is the same as for an unordered list except that it uses one or more numerical characters followed by a period followed by a space:

                ```(SAM) 
                    0. Robot
                    12. Spaceship
                    7. Ray gun

                The numbers are not retained, nor is their style. The processing application will decide the style and numbering of lists.

                Ordered list items can have multiple {paragraph}s and nested lists just like {unordered lists}, and ordered and unordered list can be nested inside each other. 

            semantics:
                The semantics of ordered lists are the same as those of {unordered list}, except, of course that the list is ordered.

            SOM:
                An unordered list is represented by an {OrderedList}(object) object. Each list item is represented by a {OrderedListItem}(object) object. 

        structure:(#labeled-list) Labeled list

            A {labeled list} is a list in which each item has a label rather than a bullet of a number. They are a close analogue of HTML definition lists. The main difference is that definition lists have false semantics. They are not always used for definitions. So SAM labeled lists are named more accurately.

            syntax:

                Labeled lists begin with a label between pipe characters. There must be no space
                between the opening pipe character and the start of the label text. (Otherwise
                it will be parsed as a {line}, not a labeled list.

                ```(SAM) 
                    |fa| A long long way to run.
                    |so| A needle pulling thread.
                    |la| A note to follow so.

                As with other lists, the content of a list item is a {paragraph} and you can add other structures after the initial paragraph by adding them at the same indent as the first paragraph. (The start of the paragraph, not the label.)

                ```(sam)
                    |Do| a deer,
                    a female deer
                    |Re| a drop of
                         golden sun

                         Is it a particle or a wave?


                    |Me| a name I call myself


            semantics:
                A {labeled list} is simply as list with a label instead of a bullet. There is no restriction built into the language as to what structures you can nest under a definition list item, but prudence would suggest that it would be appropriate to restrict things in the schema. 

            serialization:

                A {labeled list} is serialized as follows:

                ```(xml)
                    <ll>
                    <li>
                    <label>Do</label>
                    <p>a deer, a female deer</p>
                    </li>
                    <li>
                    <label>Re</label>
                    <p>a drop of golden sun</p>
                    <p>Is it a particle or a wave?</p>
                    </li>
                    </ll>

            SOM:
                A {labeled list} is represented in the SOM by a {LabeledList}(object) object. Each item is represented by a {LabeledListItem}(object) object.

        structure:(#grid) Grid

            Grids are an very simple table-like construct. They are not full tables which are complex {document domain} beasts with potentially elaborate syntax. There are many ways to do {tables} or semantically represent data that may be displayed in tables in SAM. Grids are meant for the simplest cases that have no {document domain} or {subject domain} semantics. They are just a tick tack toe board.

            syntax:

                A grid is created by starting a line with three `+` signs. These may be followed by {block annotations}.

                Each row of the grid is on a separate line. Cells are separated by pipes. There is no pipe before the first cell or after the last. All rows must have the same number of cells.

                There is no concept of a header, no row or column spanning. A grid consists of rows and cells. Each cell contains a single {flow}. Each row must be on one line of the source files. Cell contents are trimmed of leading and trailing whitespace. This allows you to align the pipes if you wish (though this is not required).

                ```(SAM)
                    +++
                        *Type*  | *Term*    | *Notes*

                        feature | fragment  | bing

                        feature | fragments | bang


                Management attributes are permitted on the grid, but not the rows.

                ```(SAM)
                    +++(*foo #bar ?baz)
                        *Type*  | *Term*    | *Notes*

                        feature | fragment  | bing

                        feature | fragments | bang

            semantics:
                A grid is nothing more than a two dimensional grid of cells. If you want any more complex representation of a table, you need to find a different way to mark it up. 

                Note that SAM is primarily intended for creating {subject domain} languages and as such it does not provide native support for complex tables, which are document domain objects. {Record sets} are the SAM-like way to represent real record data. To create document domain tables in SAM, you would need to create a table markup using {blocks} and {fields}. Another alternative would be to use {embedded XML}.

            serialization:
                Grids are serialized as follows: 

                ```(xml)
                    <grid>
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Term</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Notes</annotation></phrase></cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragments</cell>
                    <cell>bang</cell>
                    </row>
                    </grid>


            SOM:
                Grids are represented in the SOM by a {Grid} object and rows by {Row} objects.

        structure:(#comment) Comment

            A comment is a extra-textual comment on the markup of the document
            similar to a comment in code or in XML. 


            syntax:

                A comment is created by starting a line with a `#`. There 
                is no support for multi-line comments or for comments within
                running text. 

                ```(sam)
                    # This is a comment.

            semantics:
                A comment is intended as a comment on the source file. To comment on the document as a document, use {remark}s.

            serialiation:

                A comment is represented in XML as an XML comment.

                ```(xml)
                    <!-- This is a comment -->

            SOM: 
                A comment is represented in the SOM with a {Comment}(object) object.

        structure:(#remark) Remark

            A remark is an editorial comment on the document text. 

            syntax:
                A remark looks like a blockquote except that is is introduced with three `!` characters and takes a attribution attribute:

                ```(sam)
                    !!!(Mark Baker) 
                        This is a remark.

                The body of a remark is normal SAM so it can contain other SAM structures.

                Remarks can take a {id} or {language} attribute, but not a {name} or {condition} attribute. 

                Remarks are a block structure. There is not provision for including a remark in the middle of a paragraph. Generally, speaking, placing a remark after the paragraph it remarks on should be sufficient, however, if you want to anchor a remark to a specific spot in a paragraph, you can do so by giving the remark an {ID} {attribute} and referring to it using a {citation}:

                ```(sam)

                    This requires a remark[*cdg1], but the paragraph continues.

                    !!!(Charles André Joseph Marie de Gaulle)(*cdg1)(!fr)
                        La Plume de ma tante.

            semantics:
                Remarks are intended for communication between authors, editors, and reviewers during the preparation of the document. They may be presented in editors or in draft versions of output. They do not form part of the finished document.

            serialization:
                The XML representation of a {remark} is as follows:

                ```(xml)
                    <remark attribution="mbaker">
                    <p>This is a remark.</p>
                    </remark>

                Remarks anchored with a citation are serialized like this:

                ```(xml)
                    <p>This requires a remark<citation type="id" value="*cdg1"/>, but the paragraph continues.
                    <remark attribution="Charles André Joseph Marie de Gaulle" id="cdg1" xml:lang="fr">
                    <p>La Plume de ma tante.</p>
                    </remark>

        structure:(#decoration) Bold and italic decorations

            A decoration is a shortcut for creating an annotated phrase. They are used for common text formatting features  bold, and italic. Decorations are shortcuts, so

            ```(sam)
                This text is in *important* type.

            is a shortcut for

            ```(sam)
                This text is {important}(bold).

           syntax:
                Decoration are indicated by charters in the text that bracket phrases. The decorations are as follows:

                * `*` is a decoration for bold.

                * `_` is a decoration for italic


                Examples:

                ```(sam)
                    This text is in *bold* type.


                ```(sam)
                    This text is _italic_ type.


                Decorations cannot be nested, so

                ```(sam)
                    This text is *_important_*.

                is not a shortcut for

                ```(sam)
                    This text is {important}(bold)(italic)

                but would be interpreted as

                ```(sam)
                    This text is {_important_}(bold).

                Decorations are not recognized inside of {phrase}s, since decorations are shorcuts for phrases and phrases cannot be nested. Decoration characters inside annotations are read as plain text. 

                {Annotation}(structure "annotation") chaining is supported for decorations. Therefore if you want to make text both both and italic, you could use:

                ```(sam)
                    This text is *important*(italic)

                Although it may be clearer to do this:

                ```(sam)
                    This text is {important}(bold)(italic)

            semantics:

                In SAM, the bold and italic decorations are media domain structures calling for the use of bold and italic typefaces respectively. This is in contrast to most lightweight markup languages which use them (or similar markup) to mean an abstraction like "emphasis" or "strong". The problem with these abstractions is that their meaning in not clear. Bold and italic type are conventionally used for specific purposes and should not be abstracted out without some definite indication of the purpose. Thus in SAM, you would normally expect a tagging language that expected the titles of books to occur regularly in content would provide a suitable `title` annotation to mark them up. 

                ```(sam)
                    {Moby Dick}(book) is about a whale.

                But if there the tagging language provides no such support, because books are not a significant subject for that language, then the writer who needs to mention a book should not be forced to use a vague and unreliable abstraction like `emphasis` in order to ensure proper formatting of the title. They should be able to specify the correct media domain formatting choice:

                ```(sam)
                    _Moby Dick_ is about a whale.

                Which is equivalent to:

                ```(sam)
                    {Moby Dick}(italic) is about a whale.

                And we should note in this case that the abstract `emphasis` is not only vague, it is actually incorrect. This is not a case of emphasizing a word, but of formatting a book title according to the commonly accepted convention. If you actually want an emphasis annotation in your tagging language, you should do it like this:

                ```(sam)
                    {Moby Dick}(italic) is a {very}(emphasis) good book.

            serialization:

                The bold and italic decoration are serialized as bold and italic elements respectively.

                ```(xml)
                    <p>This text is in <bold>bold</bold> type.</p>

                    <p>This text is <italic>italic</italic> type.</p>

            SOM:
                The bold and italic decorations are represented in the SOM as bold and italic annotations using {Annotation} objects. No distinction is made between what were decorations in the source and what were annotations of the same name. 
               
        structure:(#inline-code) Inline code

            Inline code is used to include code or data samples in the body of a paragraph. 

            syntax:
                Inline code is indicated by surrounding it in backticks:

                ```(sam)
                    In Python 3, use `print("Hello World")`. 

                The body of an inline code structure is not parsed for character escapes or other markup, so you can do this:

                ```(sam)
                    In SAM, and phrase looks like this: `{phrase}`.

                The only character that can be escaped in inline code is the back tick, which is escaped using a double back tick: ````.


                ```(sam)
                    In Python 3, use `print("Hello World")`(python). 

                Inline code can also take all the regular attributes. 

                ```(sam)
                    In the correct form is `print("Hello World")`(python)(?p3)`print "Hello World`(python)(?p2). 

                Inline code cannot take chained annotations, however. 

            semantics:
                The content of an inline code structure to presented as code, without interpretation. It may be formatted in accordance with its language. 

            SOM:
                Inline code is represented in the SOM as an {Phrase} object with an {annotation} of "code". 
        
        structure:(#inline-embed) Inline embed

            An inline embed is a piece of embedded code that is intended to be interpreted by the application layer. For example, an inline embed could be used to embed an equation in latexmath.

            syntax:
                An inline embed looks exactly like {inline code} except that it has an annotation containing an encoding attribute, which it the name of the encoding language preceded by a `=`:

                ```(sam)
                    This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(=latexmath) in the middle of a paragraph. 

            semantics:
                The application layer should interpret the inline embed according to its language type and display the result. 

            serialization:
                ```(xml)
                    <p>This is an equation <embed encoding="latexmath">\frac{ \sum_{t=0}^{N}f(t,k) }{N}</embed> in the middle of a paragraph.</p> 

            SOM:
                An inline embed is represented in the SOM as a {Code} object with an {Encoding} attribute.

