article: 临时文件C接口

	topic: 补遗

		1. 在C的ISO标准中包含的是`tmpfile`和`tmpnam`，`tmpfile`没有文件名，`tmpnam`存在竞争问题，并且不能通过指定模板的方式规避，这导致两个的使用范围都有限。—— 2017-09-08

	如果在C程序中碰到文本处理，极有可能会涉及到临时文件的处理。

	在不同情境下，可能对临时文件接口有不同的需求。比如有时只是将临时文件作为临时的数据存储空间，无需与其它进程共享，这时可以直接使用`tmpfile()`函数。`tmpfile()`返回的是一个`FILE *`句柄，由`tmpfile()`创建的临时文件没有实际的文件名，这样处理的好处是，当程序结束时，文件不需要程序手动删除。

	但如果你需要与其它进程共享临时文件，或是需要以临时文件的文件名作为参数调用其它程序以传递数据，`tmpfile()`就不能胜任了，这时就需要用到`mkstemp()`。`mkstemp()`通过传入的模板字符串生成一个不存在的文件名，同时创建该文件，将文件句柄做为函数返回值返回，而文件名可以从被修改了的模板字符串中得到。

	以上两个函数算是比较现代的了，如果对于历史感兴趣，可以看看下面三个函数。

	`mktemp()`函数用于生成一个不存在的文件名。这个函数现在已经不提倡使用，在POSIX.1-2008中甚至已经将其删除了。从glibc `mktemp(3)`中可以了解到，不提倡使用`mktemp()`的主要原因是`mktemp()`只是生成一个当前不存在的文件名，而没有直接创建该文件。而如果需要创建这个文件，那么在`mktemp()`和`creat()`之间可能这个临时文件被其它进程创建，从而导致文件创建失败。

	`tmpnam()`函数有与`mktemp()`一样的问题，同时，当传入参数为NULL时，由于需要用到static变量，所以不是线程安全的。在POSIX.1-2008中已经不建议使用。

	`tempnam()`与`tmpnam()`相似，只是参数更多，可控性更高。同样，在POSIX.1-2008中已不建议使用。 
